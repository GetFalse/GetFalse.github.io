{"title":"限流算法","date":"2019-09-21T20:01:11.000Z","date_formatted":{"ll":"Sep 21, 2019","L":"09/21/2019","MM-DD":"09-21"},"link":"2019/09/21/2019-09-21-限流算法","comments":true,"tags":["限流"],"categories":["高可用架构"],"updated":"2020-03-07T07:09:33.602Z","content":"<h2 id=\"为什么要限流\">为什么要限流<a href=\"#为什么要限流\" title=\"为什么要限流\"></a></h2><p>限流顾名思义就是限制流量，那么为什么要限制流量，因为一个系统设计出来，以其当前的架构和配置，能承受的负载是有上限的，我们必须保证不超过这一上限，对超过限制的请求则进行快速失败或丢弃，才能保证服务稳定运行！其实我们生活中到处都存在限流，比如：汽车的单双号限行，医院预约挂号等等。</p>\n<h2 id=\"限流算法有哪些\">限流算法有哪些<a href=\"#限流算法有哪些\" title=\"限流算法有哪些\"></a></h2><p>常见的限流一般有以下三种</p>\n<h3 id=\"计数器法\">计数器法<a href=\"#计数器法\" title=\"计数器法\"></a></h3><h4 id=\"固定窗口\">固定窗口<a href=\"#固定窗口\" title=\"固定窗口\"></a></h4><p>固定窗口的实现原理很简单，就是规定一个阈值，比如说一秒内只能处理3个，在一秒内来一个请求就加一，当超过3，之后的请求就拒绝掉。如下图：</p>\n<p><img src=\"https://resource.bugbak.com//tNhVS6VBduXG3ADKuAHLjNbEtB5vHJOszCPE4EfJ.png\" class=\"φcy\"><br>以上实现有一个很大的问题就是峰值会达到两倍。比如：限制为1秒5次，在0.5<del>1秒间请求5次，然后1</del>1.5秒间请求5次，这个时候间隔1秒中就会请求10次。这种突然的流量增加很容易压垮我们的服务。如下图：</p>\n<p><img src=\"https://resource.bugbak.com//sgvBWAEATk3S3mBV43bjXTpn3LfOdyzSEyK5SXas.png\" class=\"φcy\"></p>\n<h4 id=\"滑动窗口\">滑动窗口<a href=\"#滑动窗口\" title=\"滑动窗口\"></a></h4><p>滑动窗口就是对固定窗口的一个优化，防止超过阈值的两倍。具体的实现原理就是把时间进行细分，不是统计固定时间的请求，而是动态的。意思就是将每次的请求时间记录下来，把当前时间往前滑动一秒，看这个时间区间内是否超过5个，如果超过对新来的请求就拒绝掉。这样可以牢牢的限制住1秒里面就只有5个请求。</p>\n<p><img src=\"https://resource.bugbak.com//Ld7f7yjdMoWhjM9UCD31qOBKHETk23E3Jz3y04rn.png\" class=\"φcy\"></p>\n<p>注意：</p>\n<p>计数器法不管是固定还是滑动窗口都会导致突刺问题（在一定时间内的一小段时间内就用完了所有资源，后大部分时间中无资源可用），所有对于突发流量无法很好处理。</p>\n<h3 id=\"漏桶算法\">漏桶算法<a href=\"#漏桶算法\" title=\"漏桶算法\"></a></h3><p>为了解决上述问题，我们可以将突发流量存起来然后慢慢处理，这个时候漏桶算法出现了。如图：</p>\n<p><img src=\"https://resource.bugbak.com//UNbWCvdDm2sqRS1XkmFgUO5TuS2Xw1rpHBOI4lkp.png\" class=\"φcy\"></p>\n<p>漏桶算法就是以固定的速率流出。当流入的速率高于流出，就会把多余的流量储存到桶里。当然桶也是有容积的。当超过了桶的容积，就会把多余的流量拒绝掉。</p>\n<h3 id=\"令牌桶算法\">令牌桶算法<a href=\"#令牌桶算法\" title=\"令牌桶算法\"></a></h3><p>令牌桶也可以解决突发流量的问题。如图</p>\n<p><img src=\"https://resource.bugbak.com//XZrIZUj2tK6mWuayFaSwV2tMn2sZzuT22j0wSDMk.png\" class=\"φcy\"></p>\n<p>令牌桶就是以一定的速率往桶中装令牌（这里的令牌可以理解为通行证，拿到通行证才可以进入），每次请求都去桶中拿一个令牌，如果桶里没有令牌了，就会把请求拒绝掉。如果请求的速率小于装令牌的速率，多的令牌就会储存到桶中。</p>\n<h3 id=\"漏桶算法和令牌桶算法比较\">漏桶算法和令牌桶算法比较<a href=\"#漏桶算法和令牌桶算法比较\" title=\"漏桶算法和令牌桶算法比较\"></a></h3><p>语言描述还是太苍白，我们直接举例子，我们来讨论下面几种情况：</p>\n<p>假定：漏桶的流出速率为1000/s，令牌桶的加令牌速率也为1000/s，容积都为5000</p>\n<ul><li><p>第一种情况：0-1s请求速率为500/s，1-2s请求速率为1500/s</p><p>0~1s：漏桶：全部直接通过</p><p>​ 令牌桶：也是全部直接通过，但令牌桶桶里还有多的500个</p><p>1~2s：漏桶：直接通过1000个，但还有500个放入桶中需要排队</p><p>​ 令牌桶：全部直接通过，因为桶里刚好有1500个</p></li><li><p>第二种情况： 0-1秒请求速率为1500/s，1-2秒请求速率为1500/s</p><p>0~1s：漏桶：通过1000个，存储500个排队</p><p>​ 令牌桶：通过1000个，丢弃500个</p><p>1~2s：漏桶：通过1000个，加上之前500个共1000放入桶中需要排队</p><p>​ 令牌桶：通过1000个，丢弃500个</p><p>2~ns：如果一直以这个速率持续下去漏桶达到容积5000，他们的处理结果都一样都会丢弃500</p></li></ul><p>观察上面两个例子，我们就可以看出他们两的差别，有过线上经验的可能都知道，正常提供服务的时候以情况一的场景居多，这样应对突发请求增多。由于令牌桶中有多余的令牌，我们可以快速的进行响应，而不用等待。这样对于用户的体验无疑是很好的，所以我们通常限流的实现是基于令牌桶。</p>\n<h2 id=\"生产环境中的应用\">生产环境中的应用<a href=\"#生产环境中的应用\" title=\"生产环境中的应用\"></a></h2><p>就是我们在学习一门新的知识，我们不应该只是学过，知道理论就完了，我们还需要思考，如何应用在实际。谷歌的guava包提供了令牌桶的单机实现，封装了一个RateLimiter。下面我们简单的测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RateLimiterTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个每秒放10个的令牌桶</span></span><br><span class=\"line\">        RateLimiter rateLimiter = RateLimiter.create(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">//记录上一次获得令牌的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] lastTime = &#123;System.currentTimeMillis()&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个线程模拟请求</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; ; ) &#123;<span class=\"comment\">//不间断的请求</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rateLimiter.tryAcquire()) &#123;<span class=\"comment\">//有令牌返回ture</span></span><br><span class=\"line\">                    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"耗时\"</span> + (now - lastTime[<span class=\"number\">0</span>]) + <span class=\"string\">\" pass\"</span>);</span><br><span class=\"line\">                    lastTime[<span class=\"number\">0</span>] = now;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">耗时100 pass</span><br><span class=\"line\">耗时100 pass</span><br><span class=\"line\">耗时100 pass</span><br><span class=\"line\">耗时99 pass</span><br></pre></td></tr></table></figure>\n\n<p>可以看出设置一秒10个，则是按照规律的每100ms放置一个，桶的容积也是10。<br>rateLimiter提供了acquire()和tryAcquire() 两个方法</p>\n<ol><li>使用acquire()方法，如果没有可用令牌，会一直阻塞直到有足够的令牌。</li><li>使用tryAcquire()方法，如果没有可用令牌，就直接返回false。</li><li>使用tryAcquire()带超时时间的方法，如果没有可用令牌，就会判断在超时时间内是否可以等到令牌，如果不能，就返回false，如果可以，就阻塞等待。</li></ol><p>由于现阶段线上要么集群要么分布式，单机上实现显然实用性不高，由于篇幅太长，我们将在另一篇博文中实现。</p>\n<h2 id=\"参考\">参考<a href=\"#参考\" title=\"参考\"></a></h2><p><a href=\"https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673\" target=\"_blank\">https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673</a></p>\n","next":{"title":".gitignore语法规范","link":"2019/09/13/2019-09-13-.gitignore语法规范"},"plink":"https://blog.bugbak.com/2019/09/21/2019-09-21-限流算法/","toc":[{"id":"为什么要限流","title":"为什么要限流","index":"1"},{"id":"限流算法有哪些","title":"限流算法有哪些","index":"2","children":[{"id":"计数器法","title":"计数器法","index":"2.1"},{"id":"漏桶算法","title":"漏桶算法","index":"2.2"},{"id":"令牌桶算法","title":"令牌桶算法","index":"2.3"},{"id":"漏桶算法和令牌桶算法比较","title":"漏桶算法和令牌桶算法比较","index":"2.4"}]},{"id":"生产环境中的应用","title":"生产环境中的应用","index":"3"},{"id":"参考","title":"参考","index":"4"}],"reward":true,"copyright":{"author":"Dz","link":"<a href=\"https://blog.bugbak.com/2019/09/21/2019-09-21-限流算法/\" title=\"限流算法\">https://blog.bugbak.com/2019/09/21/2019-09-21-限流算法/</a>","license":"本博客所有文章除特别声明外，均采用(<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"nofollow\" target=\"_blank\">CC BY-NC-SA 4.0</a>)许可协议，转载请注明来源<a href=\"https://blog.bugbak.com\" rel=\"nofollow\" target=\"_blank\">BugBak</a>"}}