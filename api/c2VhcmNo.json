[{"title":"限流算法","date":"2019-09-21T20:01:11.000Z","date_formatted":{"ll":"Sep 21, 2019","L":"09/21/2019","MM-DD":"09-21"},"updated":"2020-03-07T07:09:33.602Z","content":"为什么要限流限流顾名思义就是限制流量，那么为什么要限制流量，因为一个系统设计出来，以其当前的架构和配置，能承受的负载是有上限的，我们必须保证不超过这一上限，对超过限制的请求则进行快速失败或丢弃，才能保证服务稳定运行！其实我们生活中到处都存在限流，比如：汽车的单双号限行，医院预约挂号等等。\n限流算法有哪些常见的限流一般有以下三种\n计数器法固定窗口固定窗口的实现原理很简单，就是规定一个阈值，比如说一秒内只能处理3个，在一秒内来一个请求就加一，当超过3，之后的请求就拒绝掉。如下图：\n以上实现有一个很大的问题就是峰值会达到两倍。比如：限制为1秒5次，在0.51秒间请求5次，然后11.5秒间请求5次，这个时候间隔1秒中就会请求10次。这种突然的流量增加很容易压垮我们的服务。如下图：\n\n滑动窗口滑动窗口就是对固定窗口的一个优化，防止超过阈值的两倍。具体的实现原理就是把时间进行细分，不是统计固定时间的请求，而是动态的。意思就是将每次的请求时间记录下来，把当前时间往前滑动一秒，看这个时间区间内是否超过5个，如果超过对新来的请求就拒绝掉。这样可以牢牢的限制住1秒里面就只有5个请求。\n\n注意：\n计数器法不管是固定还是滑动窗口都会导致突刺问题（在一定时间内的一小段时间内就用完了所有资源，后大部分时间中无资源可用），所有对于突发流量无法很好处理。\n漏桶算法为了解决上述问题，我们可以将突发流量存起来然后慢慢处理，这个时候漏桶算法出现了。如图：\n\n漏桶算法就是以固定的速率流出。当流入的速率高于流出，就会把多余的流量储存到桶里。当然桶也是有容积的。当超过了桶的容积，就会把多余的流量拒绝掉。\n令牌桶算法令牌桶也可以解决突发流量的问题。如图\n\n令牌桶就是以一定的速率往桶中装令牌（这里的令牌可以理解为通行证，拿到通行证才可以进入），每次请求都去桶中拿一个令牌，如果桶里没有令牌了，就会把请求拒绝掉。如果请求的速率小于装令牌的速率，多的令牌就会储存到桶中。\n漏桶算法和令牌桶算法比较语言描述还是太苍白，我们直接举例子，我们来讨论下面几种情况：\n假定：漏桶的流出速率为1000/s，令牌桶的加令牌速率也为1000/s，容积都为5000\n第一种情况：0-1s请求速率为500/s，1-2s请求速率为1500/s0~1s：漏桶：全部直接通过​ 令牌桶：也是全部直接通过，但令牌桶桶里还有多的500个1~2s：漏桶：直接通过1000个，但还有500个放入桶中需要排队​ 令牌桶：全部直接通过，因为桶里刚好有1500个第二种情况： 0-1秒请求速率为1500/s，1-2秒请求速率为1500/s0~1s：漏桶：通过1000个，存储500个排队​ 令牌桶：通过1000个，丢弃500个1~2s：漏桶：通过1000个，加上之前500个共1000放入桶中需要排队​ 令牌桶：通过1000个，丢弃500个2~ns：如果一直以这个速率持续下去漏桶达到容积5000，他们的处理结果都一样都会丢弃500观察上面两个例子，我们就可以看出他们两的差别，有过线上经验的可能都知道，正常提供服务的时候以情况一的场景居多，这样应对突发请求增多。由于令牌桶中有多余的令牌，我们可以快速的进行响应，而不用等待。这样对于用户的体验无疑是很好的，所以我们通常限流的实现是基于令牌桶。\n生产环境中的应用就是我们在学习一门新的知识，我们不应该只是学过，知道理论就完了，我们还需要思考，如何应用在实际。谷歌的guava包提供了令牌桶的单机实现，封装了一个RateLimiter。下面我们简单的测试一下：\n1234567891011121314151617181920import com.google.common.util.concurrent.RateLimiter;public class RateLimiterTest &#123;    public static void main(String[] args) &#123;        //创建一个每秒放10个的令牌桶        RateLimiter rateLimiter = RateLimiter.create(10);        //记录上一次获得令牌的时间        final long[] lastTime = &#123;System.currentTimeMillis()&#125;;        //创建一个线程模拟请求        new Thread(() -&gt; &#123;            for (; ; ) &#123;//不间断的请求                if (rateLimiter.tryAcquire()) &#123;//有令牌返回ture                    long now = System.currentTimeMillis();                    System.out.println(\"耗时\" + (now - lastTime[0]) + \" pass\");                    lastTime[0] = now;                &#125;            &#125;        &#125;).start();    &#125;&#125;\n\n运行结果：\n1234耗时100 pass耗时100 pass耗时100 pass耗时99 pass\n\n可以看出设置一秒10个，则是按照规律的每100ms放置一个，桶的容积也是10。rateLimiter提供了acquire()和tryAcquire() 两个方法\n使用acquire()方法，如果没有可用令牌，会一直阻塞直到有足够的令牌。使用tryAcquire()方法，如果没有可用令牌，就直接返回false。使用tryAcquire()带超时时间的方法，如果没有可用令牌，就会判断在超时时间内是否可以等到令牌，如果不能，就返回false，如果可以，就阻塞等待。由于现阶段线上要么集群要么分布式，单机上实现显然实用性不高，由于篇幅太长，我们将在另一篇博文中实现。\n参考https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673\n","plink":"https://blog.bugbak.com/2019/09/21/2019-09-21-限流算法/"},{"title":".gitignore语法规范","date":"2019-09-13T20:47:12.000Z","date_formatted":{"ll":"Sep 13, 2019","L":"09/13/2019","MM-DD":"09-13"},"updated":"2020-03-07T06:59:35.814Z","content":".gitignore为何物？从名字就可以看出来，就是在git里面忽略一些文件，比如：idea打开项目后的.idea文件。这些文件没有必要上传到git仓库，而且每个人idea的配置可能还不一样，pull下来别人的配置还可能会导致一些谜之问题。这时候聪明的同学肯定就会说，把不需要的文件不add到git中不就可以了吗？没错，让git不去管理这些文件的确是可以的，但人都会犯错，不保证每个人都不会将这些文件提交上去，但是被gitignore忽视的这些文件，是永远都提交不上去的，就可以化解人为的操作失误。\n如何使用.gitignore在项目的根目录里面也就是.git文件夹的同级目录下创建一个.gitignore文件，看不见.git文件夹的，打开显示隐藏文件夹。注意.gitignore这个名字已经包括了名称和后缀，千万别创建了一个.gitignore.txt文件。创建好之后我们按照官方给定的语法进行配置，就可以指定忽略哪些文件或文件夹。\n.ignore语法示例文字都是苍白的，下面我们来实操一波，以下都是我实测所得，如有纰漏，欢迎评论指出！\n注：配图中黄色是被git忽略的\n12345678# *用来匹配零个或多个字符，忽略所有.txt后缀的文件*.txt# 如果想让a.txt不被忽略，可以加上！注意：顺序和上面颠倒会失效!a.txt# 忽略所有a.txt,b.txt文件不包括ab.txt，[]用来匹配括号内任意一个字符，[0-9]匹配0到9的数[ab].txt# 用?配单个字符，忽略a.txt,不会略ab.txt?.txt\n\n123#忽略所有doc文件夹里面所有，不管doc是否为一级二级，这里的一级指的是和.gitignore同级，这两个效果一致docdoc/\n\n\n12# 忽略doc文件夹下所有，不包括/dom/doc，也就是它作为一级目录下递归所有/doc\n\n\n12# 忽略doc作为一级目录下的，不包括/dom/doc/a.txt,不包括子目录/doc/img/a.txtdoc/*.txt\n\n\n12# 忽略doc作为一级目录下的，二级目录里面的txt文件，不包括第三级目录，额。。。懵逼了，还是看图吧，一图胜千言doc/*/*.txt\n\n\n12# 忽略doc作为一级目录下的所有.txt文件doc/**/*.txt\n\n\n补充说明使用idea开发项目的小伙伴可以下载插件.ignore，被忽略的文件或者文件夹会改变颜色。这样就可以很轻松的辨别自己的配置是否成功。\n","plink":"https://blog.bugbak.com/2019/09/13/2019-09-13-.gitignore语法规范/"},{"title":"About Me","date":"2019-07-20T09:43:19.000Z","date_formatted":{"ll":"Jul 20, 2019","L":"07/20/2019","MM-DD":"07-20"},"updated":"2020-03-05T11:23:20.968Z","content":"首先告诉你一个不幸的消息，你将会在这个页面失去1分钟的青春。但是！莫慌~通过阅读鄙人的blog你可以节省至少X小时的青春嗯 ？ X？？你细品~有人可能会问鄙人为什么决定写blog？问的好！鄙人在互联网搬砖也有些年头了最明显的不是肌肉变发达了而是头发少了咳咳~是记忆力消退没错东西写出来肯定就不会丢了啊这时候肯定就有狼人跳出来指着我的鼻子说数据库炸了不久丢了吗？说的好，所以我。。。一拳打爆你的狗头哦~开个玩笑~最后如果我的输出能让大家有所收获那可真是令人开心哦~哈哈哈哈哈~\n","plink":"https://blog.bugbak.com/about/me/"}]