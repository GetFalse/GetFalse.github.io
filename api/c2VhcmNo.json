[{"title":"Feign","date":"2020-10-12T15:01:11.000Z","date_formatted":{"ll":"Oct 12, 2020","L":"10/12/2020","MM-DD":"10-12"},"updated":"2020-03-12T07:29:21.433Z","content":"什么是Feign声明式REST客户端\n如何接入Feign承接Ribbon+RestTemplate，删除依赖spring-cloud-starter-netflix-ribbon，导入依赖包（其实feign中有ribbon的包）\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在启动类添加注解@EnableFeignClients\n1234567891011121314151617181920212223242526272829303132333435import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestController@EnableFeignClientspublic class EurekaClientConsumeApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaClientConsumeApplication.class, args);    &#125;    //表示对应客户端的名字    @FeignClient(\"eureka-client\")    public interface StoreClient &#123;        @GetMapping(\"/get\")        String get();    &#125;    @Autowired    private StoreClient storeClient;    @GetMapping(value = \"/add\")    public String add() &#123;        //去调用eureka-client中get接口        return storeClient.get();    &#125;&#125;\n\n这样就实现了服务间的调用，然后自带负载均衡\n参考https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html\n","plink":"https://blog.bugbak.com/2020/10/12/Feign/"},{"title":"Ribbon+RestTemplate","date":"2020-10-12T10:01:11.000Z","date_formatted":{"ll":"Oct 12, 2020","L":"10/12/2020","MM-DD":"10-12"},"updated":"2020-03-12T07:29:12.839Z","content":"基于之前的Eureka文章，实现被注册的client服务之间的调用。\n准备工作先启动eureka-server服务，用于提供注册中心。\n原有的EurekaClient项目在启动类中新增接口用于测试：\n1234567891011121314151617181920212223import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@SpringBootApplication@RestControllerpublic class EurekaClientApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaClientApplication.class, args);    &#125;    @Value(\"$&#123;server.port&#125;\")    private String port;    @GetMapping(\"/get\")    public String get()&#123;        return port+\"-ok\";    &#125;&#125;\n\n打包后启动两个实例作为提供服务方用于负载，命令如下：java -jar -Dserver.port=8081 eureka-client-0.0.1-SNAPSHOT.jarjava -jar -Dserver.port=8082 eureka-client-0.0.1-SNAPSHOT.jar\n新增一个消费者新建一个项目EurekaClientConsume，和eureka-client的依赖相同，另新增如下依赖包（用于负载均衡）\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml如下\n1234567891011121314151617#公共配置server:    port: 8080spring:    #服务名称，更关键，使用feign进行服务消费将以此为依据    application:        name: eureka-client-consume#配置eureka获取服务地址eureka:    client:        serviceUrl:            defaultZone: http://$&#123;spring.cloud.client.ip-address&#125;:8761/eureka/    #配置instance相关信息    instance:        preferIpAddress: true        instanceId: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;\n\n启动类中新增代码如下：\n1234567891011121314151617181920212223242526272829303132import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@SpringBootApplication@RestControllerpublic class EurekaClientConsumeApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaClientConsumeApplication.class, args);    &#125;    @Bean //定义REST客户端，RestTemplate实例    @LoadBalanced//开启负载均衡的能力，不开启无法识别eureka-client    RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;    @Autowired    private RestTemplate restTemplate;    @GetMapping(\"/get\")    public String store()&#123;        return restTemplate.getForEntity(\"http://eureka-client/get\", String.class).getBody();    &#125;&#125;\n\n启动EurekaClientConsume，访问http://localhost:8080/get，会发现返回8081-ok，8082-ok交替出现，那是因为默认的负载策略是轮询。\n最后本人不太喜欢这种方式，这种跨服务调用没有那种本地调用的感觉。。。更倾向性于用Feign\n","plink":"https://blog.bugbak.com/2020/10/12/Ribbon+RestTemplate/"},{"title":"SpringCloudSleuth","date":"2020-03-17T11:01:11.000Z","date_formatted":{"ll":"Mar 17, 2020","L":"03/17/2020","MM-DD":"03-17"},"updated":"2020-03-18T02:44:51.152Z","content":"什么是SpringCloudSleuth分布式服务跟踪\n如何接入SpringCloudSleuth分别在生产者和消费者中引入依赖\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;&lt;/dependency&gt;\n\n编写测试类，输出日志如下\n123452020-03-17 11:13:20.587  INFO [eureka-client-consume,14ff8837105039d6,6416620fd7783eaf,false] 15288 --- [LIB$$90315295-2] c.b.e.EurekaClientConsumeApplication     : 发起调用2020-03-17 11:13:20.592  INFO [eureka-client,14ff8837105039d6,a77a7d1125f96e57,false] 17732 --- [nio-8081-exec-5] c.b.e.EurekaClientApplication            : 接受调用\n\n可以看到，日志里出现了[eureka-client-consume,14ff8837105039d6,6416620fd7783eaf,false]信息，这些信息由Spring Cloud Sleuth生成，用于跟踪微服务请求链路。这些信息包含了4个部分的值，它们的含义如下：\neureka-client-consume微服务的名称，与spring.application.name对应；14ff8837105039d6称为Trace ID，在一条完整的请求链路中，这个值是固定的。观察上面的日志即可证实这一点；6416620fd7783eaf称为Span ID，它表示一个基本的工作单元；false表示是否要将该信息输出到Zipkin等服务中来收集和展示，这里我们还没有集成Zipkin，所以为false引入Zipkin收集日志springboot2.2.*之后不推荐自定义Zipkin-server，所有我我们去官网下载jar包直接运行，https://zipkin.io/pages/quickstart.html，\n在消费者和生产者中引入\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml中添加\n123spring:   zipkin:    base-url: http://localhost:9411\n\n启动生产者和消费者就，调用接口，就可以在http://localhost:9411追踪调用链了。\n","plink":"https://blog.bugbak.com/2020/03/17/SpringCloudSleuth/"},{"title":"Swagger2","date":"2020-03-16T10:01:11.000Z","date_formatted":{"ll":"Mar 16, 2020","L":"03/16/2020","MM-DD":"03-16"},"updated":"2020-03-18T02:45:03.485Z","content":"环境介绍springboot：2.2.5swagger2：2.9.2JDK：1.8\n什么是SwaggerSwagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。相对于传统的手动编写API文档，Swagger能够保证实时性，文档随代码一起更新，这样可以解决应文档未更新导致的一系列沟通问题。\n如何集成Swagger2引入依赖包1234567891011121314&lt;properties&gt;    &lt;swagger2.version&gt;2.9.2&lt;/swagger2.version&gt;&lt;/properties&gt;&lt;dependency&gt;     &lt;groupId&gt;io.springfox&lt;/groupId&gt;     &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;     &lt;version&gt;$&#123;swagger2.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;$&#123;swagger2.version&#125;&lt;/version&gt;&lt;/dependency&gt;\n\n创建配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ParameterBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.schema.ModelRef;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.service.Parameter;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.Collections;import java.util.List;@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket api() &#123;        // 添加请求参数，我们这里把token作为请求头部参数传入后端        ParameterBuilder parameterBuilder = new ParameterBuilder();        List&lt;Parameter&gt; parameters = new ArrayList&lt;&gt;();        parameterBuilder.name(\"Authorization\").description(\"令牌\").modelRef(new ModelRef(\"string\")).parameterType(\"header\")                .required(false).defaultValue(\"Bearer \").build();        parameters.add(parameterBuilder.build());        return new Docket(DocumentationType.SWAGGER_2)                .select()                .apis(RequestHandlerSelectors.basePackage(\"com.bugbak.mail.controller\"))//这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。                .paths(PathSelectors.any())//这种方式可以通过筛选 API 的 url 来进行过滤。                .build()                .globalOperationParameters(parameters)                .apiInfo(apiInfo());        /**         * 接口过滤         * .apis(RequestHandlerSelectors.basePackage(\"com.bugbak.wcbase.controller\"))         * .paths(Predicates.or(PathSelectors.ant(\"/user/add\"),         *         PathSelectors.ant(\"/user/find/*\")))         *         * 自定义响应消息         * .useDefaultResponseMessages(false)         *                 .globalResponseMessage(RequestMethod.GET, Arrays.asList(         *                         new ResponseMessageBuilder()         *                                 .code(500)         *                                 .message(\"服务器发生异常\")         *                                 .responseModel(new ModelRef(\"Error\"))         *                                 .build(),         *                         new ResponseMessageBuilder()         *                                 .code(403)         *                                 .message(\"资源不可用\")         *                                 .build()         *                 )         */    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfo(                \"Spring Boot 项目集成 Swagger 实例文档\",                \"发送EmailAPI\",                \"API V1.0\",                \"Terms of service\",                new Contact(\"XXX\", \"https://www.XXXX.com\", \"XXXX@163.com\"),                \"Apache\", \"http://www.apache.org/\", Collections.emptyList());    &#125;&#125;\n\nController配置示例如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import io.swagger.annotations.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;import springfox.documentation.annotations.ApiIgnore;import javax.mail.internet.MimeMessage;import java.io.File;@RestController@RequestMapping(\"/email\")@RefreshScope@Api(tags = \"Email发送相关\")public class EmailController &#123;    @Autowired    private JavaMailSender jms;    @Value(\"$&#123;spring.mail.username&#125;\")    private String from;    @Value(\"$&#123;self.feedbackEmail&#125;\")    private String feedbackEmail;    @Autowired    private TemplateEngine templateEngine;    @PostMapping(value = \"sendTemplateEmail\")    @ApiOperation(\"发送模板文件\")    @ApiImplicitParams(value = &#123;            @ApiImplicitParam(name = \"email\",value =\"邮箱地址\",example = \"xxxxx@163.com\"),            @ApiImplicitParam(name = \"code\",value =\"验证码\"),            @ApiImplicitParam(name = \"businessType\",value =\"业务类型\"),            @ApiImplicitParam(name = \"title\",value =\"邮件标题\"),    &#125;)    public String sendTemplateEmail(String email,String code,String businessType, String title) &#123;        MimeMessage message = null;        try &#123;            message = jms.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message, true);            helper.setFrom(from);            helper.setTo(email); // 接收地址            helper.setSubject(title); // 标题            // 处理邮件模板            Context context = new Context();            context.setVariable(\"code\", code);            context.setVariable(\"type\", businessType);            context.setVariable(\"feedbackEmail\", feedbackEmail);            String template = templateEngine.process(\"emailTemplate\", context);            helper.setText(template, true);            jms.send(message);            return \"发送成功\";        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\n\n访问地址http://localhost:8083/swagger-ui.html\n其他配置说明@Api()用在请求的类上，表示对类的说明，也代表了这个类是swagger2的资源\n参数：\n123tags：说明该类的作用，参数是个数组，可以填多个。value&#x3D;&quot;该参数没什么意义，在UI界面上不显示，所以不用配置&quot;description &#x3D; &quot;用户基本信息操作&quot;\n\n@ApiOperation()用于方法，表示一个http请求访问该方法的操作\n参数：\n12345value&#x3D;&quot;方法的用途和作用&quot;    notes&#x3D;&quot;方法的注意事项和备注&quot;    tags：说明该方法的作用，参数是个数组，可以填多个。格式：tags&#x3D;&#123;&quot;作用1&quot;,&quot;作用2&quot;&#125; （在这里建议不使用这个参数，会使界面看上去有点乱，前两个常用）\n\n@ApiModel()用于响应实体类上，用于说明实体作用\n参数：\n1description&#x3D;&quot;描述实体的作用&quot;\n\n@ApiModelProperty用在属性上，描述实体类的属性\n参数：\n123value&#x3D;&quot;用户名&quot;  描述参数的意义name&#x3D;&quot;name&quot;    参数的变量名required&#x3D;true     参数是否必选\n\n@ApiImplicitParams用在请求的方法上，包含多@ApiImplicitParam\n@ApiImplicitParam用于方法，表示单独的请求参数\n参数：\n1234567891011name&#x3D;&quot;参数ming&quot; value&#x3D;&quot;参数说明&quot; dataType&#x3D;&quot;数据类型&quot; paramType&#x3D;&quot;query&quot; 表示参数放在哪里    · header 请求参数的获取：@RequestHeader    · query   请求参数的获取：@RequestParam    · path（用于restful接口） 请求参数的获取：@PathVariable    · body（不常用）    · form（不常用） defaultValue&#x3D;&quot;参数的默认值&quot;required&#x3D;&quot;true&quot; 表示参数是否必须传\n\n@ApiParam()用于方法，参数，字段说明 表示对参数的要求和说明\n参数：\n1234name&#x3D;&quot;参数名称&quot;value&#x3D;&quot;参数的简要说明&quot;defaultValue&#x3D;&quot;参数默认值&quot;required&#x3D;&quot;true&quot; 表示属性是否必填，默认为false\n\n@ApiResponses用于请求的方法上，根据响应码表示不同响应\n一个@ApiResponses包含多个@ApiResponse\n@ApiResponse用在请求的方法上，表示不同的响应\n参数：\n12code&#x3D;&quot;404&quot;    表示响应码(int型)，可自定义message&#x3D;&quot;状态码对应的响应信息&quot;\n\n@ApiIgnore()用于类或者方法上，不被显示在页面上\n@Profile({“dev”, “test”})用于配置类上，表示只对开发和测试环境有用\n参考https://www.ibm.com/developerworks/cn/java/j-using-swagger-in-a-spring-boot-project/index.html\nhttps://zhuanlan.zhihu.com/p/49996147\n","plink":"https://blog.bugbak.com/2020/03/16/Swagger2/"},{"title":"SpringBootEmail","date":"2020-03-15T12:01:11.000Z","date_formatted":{"ll":"Mar 15, 2020","L":"03/15/2020","MM-DD":"03-15"},"updated":"2020-03-18T02:45:04.050Z","content":"依赖以及配置引入依赖\n12345678&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml\n1234567891011121314server:  port: 8083spring:  mail:    host: smtp.163.com    username: zsdimewlxdt2164542@163.com    password: sfafwaeefa    properties:      mail:        smtp:          auth: true          starttls:            enable: true            required: true\n\n编写接口12345678910111213141516171819202122232425import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;import javax.mail.internet.MimeMessage;import java.io.File;@RestController@RequestMapping(\"/email\")public class EmailController &#123;    @Autowired    private JavaMailSender jms;    @Value(\"$&#123;spring.mail.username&#125;\")    private String from;    @Value(\"$&#123;self.feedbackEmail&#125;\")    private String feedbackEmail;\n一封简单的邮件123456789101112131415@RequestMapping(\"/sendSimpleEmail\")public String sendSimpleEmail(String email, String title, String content) &#123;    try &#123;        SimpleMailMessage message = new SimpleMailMessage();        message.setFrom(from);        message.setTo(email); // 接收地址        message.setSubject(title); // 标题        message.setText(content); // 内容        jms.send(message);        return \"发送成功\";    &#125; catch (Exception e) &#123;        e.printStackTrace();        return e.getMessage();    &#125;&#125;\n一封HTML格式的邮件12345678910111213141516171819@RequestMapping(\"/sendHtmlEmail\")public String sendHtmlEmail() &#123;    MimeMessage message = null;    try &#123;        message = jms.createMimeMessage();        MimeMessageHelper helper = new MimeMessageHelper(message, true);        helper.setFrom(from);        helper.setTo(\"fafafewf@163.com\"); // 接收地址        helper.setSubject(\"一封HTML格式的邮件\"); // 标题        // 带HTML格式的内容        StringBuffer sb = new StringBuffer(\"验证码：&lt;p style='color:#6db33f'&gt;9527&lt;/p&gt;\");        helper.setText(sb.toString(), true);//true表示发送HTML格式邮件        jms.send(message);        return \"发送成功\";    &#125; catch (Exception e) &#123;        e.printStackTrace();        return e.getMessage();    &#125;&#125;\n一封带附件的邮件123456789101112131415161718192021  @RequestMapping(\"sendAttachmentsMail\")public String sendAttachmentsMail() &#123;    MimeMessage message = null;    try &#123;        message = jms.createMimeMessage();        MimeMessageHelper helper = new MimeMessageHelper(message, true);        helper.setFrom(from);        helper.setTo(\"eawfawfwaf@qq.com\"); // 接收地址        helper.setSubject(\"一封带附件的邮件\"); // 标题        helper.setText(\"详情参见附件内容！\"); // 内容        // 传入附件        FileSystemResource file = new FileSystemResource(new File(\"src/main/resources/static/file/项目文档.docx\"));        helper.addAttachment(\"项目文档.docx\", file);        jms.send(message);        return \"发送成功\";    &#125; catch (Exception e) &#123;        e.printStackTrace();        return e.getMessage();    &#125;&#125;\n一封带静态资源的邮件1234567891011121314151617181920@RequestMapping(\"sendInlineMail\")public String sendInlineMail() &#123;    MimeMessage message = null;    try &#123;        message = jms.createMimeMessage();        MimeMessageHelper helper = new MimeMessageHelper(message, true);        helper.setFrom(from);        helper.setTo(\"efawfwasef@qq.com\"); // 接收地址        helper.setSubject(\"一封带静态资源的邮件\"); // 标题        helper.setText(\"&lt;html&gt;&lt;body&gt;\t博客图：&lt;img src='cid:img'/&gt;&lt;/body&gt;&lt;/html&gt;\", true); // 内容        // 传入附件        FileSystemResource file = new FileSystemResource(new File(\"src/main/resources/static/img/sunshine.png\"));        helper.addInline(\"img\", file);//helper.addInline(\"img\", file);中的img和图片标签里cid后的名称相对应。        jms.send(message);        return \"发送成功\";    &#125; catch (Exception e) &#123;        e.printStackTrace();        return e.getMessage();    &#125;&#125;\n使用模板发送邮件12345678910111213141516171819202122232425    @Autowired    private TemplateEngine templateEngine;    @RequestMapping(\"sendTemplateEmail\")    public String sendTemplateEmail(String email, String code,String title) &#123;        MimeMessage message = null;        try &#123;            message = jms.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message, true);            helper.setFrom(from);            helper.setTo(email); // 接收地址            helper.setSubject(title); // 标题            // 处理邮件模板            Context context = new Context();            context.setVariable(\"code\", code);            String template = templateEngine.process(\"emailTemplate\", context);            helper.setText(template, true);            jms.send(message);            return \"发送成功\";        &#125; catch (Exception e) &#123;            e.printStackTrace();            return e.getMessage();        &#125;    &#125;&#125;\n\n模板文件\n12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\" /&gt;    &lt;title&gt;模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    您好，您的验证码为&lt;span th:text=\"$&#123;code&#125;\"&gt;&lt;/span&gt;，请在两分钟内使用完成操作。&lt;/body&gt;&lt;/html&gt;\n\n参考https://github.com/wuyouzhuguli/SpringAll/tree/master/22.Spring-Boot-Email\n","plink":"https://blog.bugbak.com/2020/03/15/SpringBootEmail/"},{"title":"SpringBootActuator","date":"2020-03-15T10:01:11.000Z","date_formatted":{"ll":"Mar 15, 2020","L":"03/15/2020","MM-DD":"03-15"},"updated":"2020-03-18T02:45:03.004Z","content":"pom.xml文件\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n启动类中\n1234@Bean //为了开启HttpTrace端点public HttpTraceRepository httpTrace() &#123;    return new InMemoryHttpTraceRepository();&#125;\n\napplication.yml\n12345management:  endpoints:    web:      exposure:        include: '*'  #开启所有端点\n\n访问以下链接显示所有节点\nhttp://localhost:8081/actuator\n注意：\n​    生产环境不推荐使用HttpTrace跟踪http请求，推荐使用Zipkin或Spring Cloud Sleuth\n参考https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/html/production-ready-features.html#production-ready-http-tracing\n","plink":"https://blog.bugbak.com/2020/03/15/SpringBootActuator/"},{"title":"SpringCloudBus","date":"2020-03-14T11:01:11.000Z","date_formatted":{"ll":"Mar 14, 2020","L":"03/14/2020","MM-DD":"03-14"},"updated":"2020-03-14T07:19:38.728Z","content":"此篇承接上一篇SpringCloudConfig。\n什么是SpringCloudBus消息总线\n如何接入SpringCloudBusSpringCloudBus需要基于消息中间件，rabbitmq或者kafka，本次选择的是rabbitmq。具体rabbitmq的安装可以查看另外一篇博文。\n修改ConfigServer项目pom.xml新增依赖：\n12345678&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml新增配置\n1234567891011spring:  rabbitmq: #rabbitmq配置    host: 47.106.35.110    port: 5672    username: guest    password: guest management:  endpoints:    web:      exposure:        include: bus-refresh #开启bus-refresh节点\n\n修改ConfigClient项目pom.xml新增依赖\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml新增配置\n123456spring:  rabbitmq: #rabbitmq配置    host: 47.106.35.110    port: 5672    username: guest    password: guest\n\n测试去数据库把alipay.key的value值改成hello2用post方式调用ConfigClient的接口http://localhost:8888/actuator/bus-refresh, 可以看见返回httpcode码204表示刷新成功访问ConfigClient的测试接口发现alipay.key的值已经修改为hello2参考https://cloud.spring.io/spring-cloud-static/Hoxton.RELEASE/reference/htmlsingle/#spring-cloud-bus\n","plink":"https://blog.bugbak.com/2020/03/14/SpringCloudBus/"},{"title":"SpringCloudConfig","date":"2020-03-12T20:01:11.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"updated":"2020-03-14T07:19:38.746Z","content":"环境spring-cloud：Hoxton.SR3（由于我在Hoxton.RELEASE中没有找到config-server的依赖，我猜测这个版本的cofig-server可能是有问题，所以我升级到了最新Hoxton.SR3）JDK:1.8springboot:2.2.*\n什么是SpringCloudConfig配置中心，集中管理\n如何接入SpringCloudConfigConfigServer官方推荐GIT的方式，本次采用JDBC的方式搭建ConfigServer，新建一个config项目：\npom.xml\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\t&lt;parent&gt;\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\t\t&lt;version&gt;2.2.5.RELEASE&lt;/version&gt;\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\t&lt;/parent&gt;\t&lt;groupId&gt;com.bugbak&lt;/groupId&gt;\t&lt;artifactId&gt;config&lt;/artifactId&gt;\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\t&lt;name&gt;config&lt;/name&gt;\t&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\t&lt;properties&gt;\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\t&lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Hoxton.SR3&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;\t\t &lt;!-- config服务的核心包 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;         &lt;!-- 基于JDBC搭建config的依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\t&lt;build&gt;\t\t&lt;plugins&gt;\t\t\t&lt;plugin&gt;\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\t\t\t&lt;/plugin&gt;\t\t&lt;/plugins&gt;\t&lt;/build&gt;&lt;/project&gt;\n\n启动类上加入注解@EnableConfigServer,开启服务\n12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class ConfigApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigApplication.class, args);    &#125;&#125;\n\napplication.yml\n12345678910111213141516171819202122232425262728server:  port: 8888spring:  application:    name: config-server  profiles:    active: jdbc #表示采用jdbc  cloud:    config:      label: develop #标记项目是开发环境      server:        jdbc:          sql: SELECT `KEY`, `VALUE` from system_config where APPLICATION=? and PROFILE=? and LABEL=?  datasource:    url: jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&amp;useSSL=false&amp;&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC    username: root    password: 123456    driver-class-name: com.mysql.jdbc.Driver#注册到eurekeeureka:  client:    serviceUrl:      defaultZone: http://$&#123;spring.cloud.client.ip-address&#125;:8761/eureka/  instance:    preferIpAddress: true    instanceId: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;\n\n对应的建表语句\n12345678910111213CREATE TABLE `system_config` (\t`id` INT(11) NOT NULL,\t`key` VARCHAR(50) NOT NULL,\t`value` VARCHAR(500) NOT NULL,\t`application` VARCHAR(50) NOT NULL,\t`profile` VARCHAR(50) NOT NULL,\t`label` VARCHAR(50) NOT NULL,\tPRIMARY KEY (`id`))COLLATE='utf8_general_ci'ENGINE=InnoDB;INSERT INTO `system_config` (`id`, `key`, `value`, `application`, `profile`, `label`) VALUES (6, 'alipay.key', 'hello', 'eureka-client', 'dev', 'develop');\n\n启动项目，当然注册中心Eureka也要启动，访问\nhttp://localhost:8888/eureka-client/dev/develop有下列返回就表示超过了\n123456789101112131415&#123;    \"label\": \"develop\",    \"name\": \"eureka-client\",    \"profiles\": [        \"dev\"    ],    \"propertySources\": [        &#123;            \"name\": \"eureka-client-dev\",            \"source\": &#123;                \"alipay.key\": \"hello\"            &#125;        &#125;    ]&#125;\n\nConfigClient这里我们直接用之前的eureka-client项目，新增依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml\n12345678910111213141516171819202122232425server:  port: 8081spring:  application:    name: eureka-client  cloud:    config:      label: develop #这里需要和config-server中的label对应      profile: dev  #这里激素对应数据库中的profile      #uri: http://localhost:8888 #config-server的地址（这是直连的方式，很显然单点了）      discovery:        enabled: true        service-id: config-server #从eureka中寻找config-server，这样可用性更高      eureka:  client:    serviceUrl:      defaultZone: http://$&#123;spring.cloud.client.ip-address&#125;:8761/eureka/  instance:    preferIpAddress: true    instanceId: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; #测试参数   alipay:  key: 113\n\n写个接口测试一下，就会发现alipay.key变成数据库中的hello。也就是配置中心的优先级要高于本地。这样我想了一下，敏感的参数可以不让开发支付，比如密钥这种。\n测试结果，需要重启eureka-client，新的参数才能生效，很显然这生硬，接下来我们来让他动态生效。\n配置实时生效在ConfigClient中引入依赖1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;\n\n在ConfigClient的application.yml中添加123456management:  #refresh接入点显式暴露出来  endpoints:    web:      exposure:        include: refresh\n\n在ConfigClient的启动类上添加注解@RefreshScopeOK，完成上面三步就已经配置好了。接下来我们测试一下：\n去数据库把alipay.key的value值改成hello1用post方式调用ConfigClient的接口http://localhost:8081/actuator/refresh, 可以看见返回以下表示刷新成功123[  &quot;alipay.key&quot;]\n\n访问ConfigClient的测试接口发现alipay.key的值已经修改为hello1以上的配置可以完成单个应用的刷新，那么要是应用几百个，要刷新所有的节点这就很痛苦了，所以这个时候引入了SpringCloudBus来一键刷新所有配置。\n参考https://cloud.spring.io/spring-cloud-static/Hoxton.RELEASE/reference/htmlsingle/#spring-cloud-config\n","plink":"https://blog.bugbak.com/2020/03/12/SpringCloudConfig/"},{"title":"Maven坐标与依赖","date":"2020-03-12T20:01:11.000Z","date_formatted":{"ll":"Mar 12, 2020","L":"03/12/2020","MM-DD":"03-12"},"updated":"2020-03-18T02:44:34.985Z","content":"坐标在maven中，任何构件都有明确定义的坐标。这些坐标是通过一些元素定义的，下面是nexus-indexer的坐标定义：\n1234&lt;groupId&gt;org.sonatype.nexus&lt;/groupId&gt;&lt;artifactId&gt;nexus-indexer&lt;/artifactId&gt;&lt;version&gt;2.0.0&lt;/version&gt;&lt;packing&gt;jar&lt;/packing&gt;\n\ngroupId：定义当前maven项目隶属的实际项目，一般由公司前缀+隶属项目名称组成\nartifactId：定义当前maven项目模块，一般由隶属项目名称+当前maven模块名称组成\nversion：版本号\npacking：打包方式。有jar，war等，默认为jar classifier：定义构件输出的一些附属构件。本例主构件输出nexus-indexer-2.0.0.jar，附属构件比如有：nexus-indexer-2.0.0-javadoc.jar，nexus-indexer-2.0.0-source.jar等\n依赖配置除了上面的基本坐标定义，依赖还可以包含：\n123456789101112131415161718192021&lt;project&gt;    ...    &lt;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;... &lt;/groupId&gt;            &lt;artifactId&gt;... &lt;/artifactId&gt;            &lt;version&gt;... &lt;/version&gt;            &lt;type&gt;... &lt;/type&gt;            &lt;scope&gt;... &lt;/scope&gt;            &lt;optional&gt;... &lt;/optional&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                ...                &lt;/exclusion&gt;            ...                &lt;/exclusions&gt;        &lt;/dependency&gt;        ...    &lt;/dependency&gt;    ...&lt;/project&gt;\n\n\n\ntype：依赖的类型，对应坐标中的packing，默认为jar，一般不用声明\nscope：依赖的范围\noptional：标记依赖是否可选，若为true则为可选依赖。可选依赖不能传递\nexclusions：用来排除传递性依赖\n依赖范围在一个maven项目中主要有三个classpath：编译classpath，测试classpath，运行时classpath。下表列出了依赖范围和classpath的关系：\n\n依赖范围 （Scope）对于编译 classpath有效对于测试 classpath有效对于运行时 classpath有效例子\n\ncompile√√√spring-core\n\ntest×√×JUnit\n\nprovided√√×servlet-api\n\nruntime×√√JDBC驱动实现\n\nsystem√√×本地的，Maven仓库外的 类库文件\ncompile：编译依赖范围\ntest：测试依赖范围\nprovided：已提供依赖范围\nruntime：运行时依赖范围\nsystem：系统依赖范围\nimport：导入依赖范围\n传递性依赖现有pom如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;     xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;groupId&gt;com.juven.mvnbook.account&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;account-email&lt;&#x2F;artifactId&gt;    &lt;name&gt;Account Email&lt;&#x2F;name&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;        &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;            &lt;version&gt;4.3.3.RELEASE&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;            &lt;version&gt;4.3.3.RELEASE&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;            &lt;version&gt;4.3.3.RELEASE&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;            &lt;version&gt;4.3.3.RELEASE&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.mail&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;mail&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.4.7&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;            &lt;version&gt;4.7&lt;&#x2F;version&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.icegreen&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;greenmail&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.5.2&lt;&#x2F;version&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;        &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;                &lt;&#x2F;configuration&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;&lt;&#x2F;project&gt;\n\n\n\n上面的xml中有一个org.springframework：spring-core.4.3.3.RELEASE.jar依赖。在中央仓库查看其xml，会发现其还包含了：\n123456&lt;dependency&gt;    &lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2&lt;&#x2F;version&gt;    &lt;scope&gt;compile&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;\n\n\n\n该依赖的范围为compile，而spring-core依赖没有直接声明依赖范围，默认为compile。现在account-email有一个compile范围的spring-core依赖，spring-core有一个compile范围的comms-logging依赖，所以comms-logging会成为account-email的compile范围的传递性依赖。\n现假设A依赖于B，B依赖于C，那么A相对于B是第一直接依赖，B相对于C是第二直接依赖，A相对于C是传递性依赖，其依赖范围按下表定义：\n\ncompiletestprovidedruntime\n\ncompilecompile——compile\n\ntesttest——test\n\nprovidedprovided—providedprovided\n\nruntimeruntime——runtime\n表中，第一列是第一直接依赖范围，第一行是第二直接依赖范围，交叉部分是最终传递性依赖范围。\n依赖调解依赖调解有两个原则：\n1.路径最近的优先\n现在有如下两个依赖：\nA → B → C → X（1.0.0）\nA → B → X（1.2.1）\nA有两个版本的传递性依赖X，因为X（1.2.1）路径较短，所以最终X（1.2.1）会被解析使用。\n2.第一声明者优先\n现在有如下两个依赖：\nA → B → X（1.0.0）\nA → B → X（1.2.1）\n两个版本X的依赖路径一样长，这时候谁被解析取决于谁先定义！\n排除依赖使用compile:tree查看依赖树：\n123456789101112131415[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ account-email ---[INFO] com.juven.mvnbook.account:account-email:jar:1.0.0-SNAPSHOT[INFO] +- org.springframework:spring-core:jar:4.3.3.RELEASE:compile[INFO] |  \\- commons-logging:commons-logging:jar:1.2:compile[INFO] +- org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context:jar:4.3.3.RELEASE:compile[INFO] |  +- org.springframework:spring-aop:jar:4.3.3.RELEASE:compile[INFO] |  \\- org.springframework:spring-expression:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context-support:jar:4.3.3.RELEASE:compile[INFO] +- javax.mail:mail:jar:1.4.7:compile[INFO] |  \\- javax.activation:activation:jar:1.1:compile[INFO] +- junit:junit:jar:4.7:test[INFO] \\- com.icegreen:greenmail:jar:1.5.2:test[INFO]    +- com.sun.mail:javax.mail:jar:1.5.6:test[INFO]    \\- org.slf4j:slf4j-api:jar:1.7.21:test\n\n\n\n如上所述的，spring-core隐式依赖于commons-logging，如果不想传递此依赖，可以为spring-core添加exclusions元素：\n1234567891011&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.3.3.RELEASE&lt;&#x2F;version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;commons-logging&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;commons-logging&lt;&#x2F;artifactId&gt;        &lt;&#x2F;exclusion&gt;    &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt;\n\n\n\n再次执行dependency:tree命令：\n1234567891011121314[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ account-email ---[INFO] com.juven.mvnbook.account:account-email:jar:1.0.0-SNAPSHOT[INFO] +- org.springframework:spring-core:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context:jar:4.3.3.RELEASE:compile[INFO] |  +- org.springframework:spring-aop:jar:4.3.3.RELEASE:compile[INFO] |  \\- org.springframework:spring-expression:jar:4.3.3.RELEASE:compile[INFO] +- org.springframework:spring-context-support:jar:4.3.3.RELEASE:compile[INFO] +- javax.mail:mail:jar:1.4.7:compile[INFO] |  \\- javax.activation:activation:jar:1.1:compile[INFO] +- junit:junit:jar:4.7:test[INFO] \\- com.icegreen:greenmail:jar:1.5.2:test[INFO]    +- com.sun.mail:javax.mail:jar:1.5.6:test[INFO]    \\- org.slf4j:slf4j-api:jar:1.7.21:test\n\n\n\n可发现spring-core已经不依赖于commons-logging了，当然这里只是单纯演示排除依赖，commons-logging对于Spring框架是必须的。\n归类依赖在上述的pom中，spring的版本都为4.3.3.RELEASE版本，而且对于一个框架来说，其各个模块的版本一般都是一样的，这里我们可以统一声明其版本，然后引用即可：\n123456789101112131415161718192021222324&lt;properties&gt;    &lt;springframework.version&gt;4.3.3.RELEASE&lt;&#x2F;springframework.version&gt;&lt;&#x2F;properties&gt;...&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;springframework.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;springframework.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;springframework.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;springframework.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;\n\n\n\n这样在以后更新spring版本的时候，只需要修改properties即可。\n优化依赖除了使用dependency:tree命令外，还可使是dependency:list查看所有依赖：\ndependency:list\n12345678910111213141516[INFO] --- maven-dependency-plugin:2.8:list (default-cli) @ account-email ---[INFO] [INFO] The following files have been resolved:[INFO]    org.springframework:spring-beans:jar:4.3.3.RELEASE:compile[INFO]    org.springframework:spring-context-support:jar:4.3.3.RELEASE:compile[INFO]    org.slf4j:slf4j-api:jar:1.7.21:test[INFO]    junit:junit:jar:4.7:test[INFO]    com.sun.mail:javax.mail:jar:1.5.6:test[INFO]    com.icegreen:greenmail:jar:1.5.2:test[INFO]    commons-logging:commons-logging:jar:1.2:compile[INFO]    org.springframework:spring-aop:jar:4.3.3.RELEASE:compile[INFO]    javax.activation:activation:jar:1.1:compile[INFO]    javax.mail:mail:jar:1.4.7:compile[INFO]    org.springframework:spring-core:jar:4.3.3.RELEASE:compile[INFO]    org.springframework:spring-context:jar:4.3.3.RELEASE:compile[INFO]    org.springframework:spring-expression:jar:4.3.3.RELEASE:compile\n\n\n\n使用dependency:analyze分析依赖：\n123456[INFO] &lt;&lt;&lt; maven-dependency-plugin:2.8:analyze (default-cli) @ account-email &lt;&lt;&lt;[INFO] [INFO] --- maven-dependency-plugin:2.8:analyze (default-cli) @ account-email ---[WARNING] Unused declared dependencies found:[WARNING]    org.springframework:spring-core:jar:4.3.3.RELEASE:compile[WARNING]    org.springframework:spring-beans:jar:4.3.3.RELEASE:compile","plink":"https://blog.bugbak.com/2020/03/12/Maven/"},{"title":"Springboot-YML配置技巧","date":"2020-03-11T17:01:11.000Z","date_formatted":{"ll":"Mar 11, 2020","L":"03/11/2020","MM-DD":"03-11"},"updated":"2020-03-12T07:41:05.888Z","content":"多文档配置用---将文档区分，这样在一个application.yml中配置多个环境，示例如下：\n1234567891011121314151617181920212223#这里可以将相同配置配置在这里。spring:  profiles:    active: prod#用---将文档划分---server:  port: 8081spring:  profiles: dev---server:  port: 8082spring:  profiles: test  ---server:  port: 8083spring:  profiles: prod\n\n之前我都是创建多个文件application-dev.yml，application-prod.yml。这里可以权衡一下，如果配置很多都不同可以选择创建多个文件，毕竟看起来清晰。少量不同可以使用多文档配置。\n自动提示比如接入支付宝支付会有很多参数，这个时候可以这样。\n1234567891011import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@ConfigurationProperties(prefix = \"alipay\")@Component@Datapublic class AlipayProperties &#123;    private String appid;    private String key;&#125;\n\n然后我们去yml文件里面配置，这个时候没有提示，写起来麻烦。这个时候可以导入包，编译之后会在META-INF文件夹下生成文件spring-configuration-metadata.json\n12345&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n\n这个时候就输入alipay，就会有自动提示了\n","plink":"https://blog.bugbak.com/2020/03/11/Yml配置技巧/"},{"title":"Eureka-bak-01","date":"2020-03-11T15:01:11.000Z","date_formatted":{"ll":"Mar 11, 2020","L":"03/11/2020","MM-DD":"03-11"},"updated":"2020-03-12T07:29:02.849Z","content":"EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.\n访问Eureka控制页面，提示如上，中文解释：紧急!EUREKA可能错误地声明实例已经启动，而实际上它们并没有。续订低于阈值，因此不会为了安全而终止实例。这是由于Renews threshold = 3，Renews (last min)= 2导致的。先解释一下说明这两个参数的含义\nRenews threshold：server期望在每分钟中收到的心跳次数 。Renews (last min)：上一分钟内收到的心跳次数。\nEurake有一个配置参数eureka.server.renewalPercentThreshold，定义了renews 和renews threshold的比值，默认值为0.85。当server在15分钟内，比值低于percent，即少了15%的微服务心跳，server会进入自我保护状态，Self-Preservation。在此状态下，server不会删除注册信息，这就有可能导致在调用微服务时，实际上服务并不存在。这种保护状态实际上是考虑了client和server之间的心跳是因为网络问题，而非服务本身问题，不能简单的删除注册信息\nstackoverflow上，有人给出的建议是：1、在生产上可以开自注册，部署两个server2、在本机器上测试的时候，可以把比值调低，比如0.493、或者简单粗暴把自我保护模式关闭\n参考https://www.cnblogs.com/breath-taking/articles/7940364.html\n","plink":"https://blog.bugbak.com/2020/03/11/Eureka-bak-01/"},{"title":"SpringCloudEureka","date":"2020-03-11T10:01:11.000Z","date_formatted":{"ll":"Mar 11, 2020","L":"03/11/2020","MM-DD":"03-11"},"updated":"2020-03-12T07:28:52.440Z","content":"搭建环境SpringBoot: 2.2.0.RELEASESpringCloud: Hoxton.RELEASEJDK1.8.0_162Maven3.5.3\nSpringCloudEureka是什么服务发现治理\n如何接入SpringCloudEurekaEurekaServer新建一个项目eureka-server，导入依赖包pom.xml文件如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.bugbak&lt;/groupId&gt;    &lt;artifactId&gt;eureka-server&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;eureka-server&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Hoxton.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\n启动类添加注解@EnableEurekaServer,表示开启服务\n12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServerApplication.class, args);    &#125;&#125;\n\napplication.yml如下配置\n1234567891011121314151617181920212223server:  port: 8761eureka:  server:    #是否开启自我保护模式#    enableSelfPreservation: false    #配置Eureka Server清理无效节点的时间间隔    eviction-interval-timer-in-ms: 4000  instance:    #配置与此实例相关联的主机名，是其他实例可以用来进行请求的准确名称    hostname: eureka-server    #显示服务ip地址    preferIpAddress: true    #获取服务的ip和端口    instanceId: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;  client:    #此客户端是否将自己注册到eureka注册中心    registerWithEureka: false    #此客户端是否获取eureka服务器注册表上的注册信息    fetchRegistry: false    serviceUrl:      #配置默认节点有信息      defaultZone: http://$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;/eureka/\n\n启动项目访问http://localhost:8761/就可以看见Eureka的控制后台\nEurekaClient新建一个项目eureka-client，依赖pom文件如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.bugbak&lt;/groupId&gt;    &lt;artifactId&gt;eureka-client&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;eureka-client&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Hoxton.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\napplication.yml如下配置\n1234567891011121314151617#公共配置server:  port: 8081spring:  #服务名称，(使用feign进行服务消费将以此为依据,之后再讲）  application:    name: eureka-client#配置eureka获取服务地址eureka:  client:    serviceUrl:      defaultZone: http://$&#123;spring.cloud.client.ip-address&#125;:8761/eureka/  #配置instance相关信息  instance:    preferIpAddress: true    instanceId: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;\n\n启动之后项目之后就会发现项目已经注册进去了。\n\n最后我在配置项目的时候遇到一些问题，解决方法已经写在bak标签里面了，如果遇到问题，可以去bak标签中查看是否有同样的问题。\n参考https://cloud.spring.io/spring-cloud-netflix/reference/html/\n","plink":"https://blog.bugbak.com/2020/03/11/SpringCloudEurope/"},{"title":"SpringCloudGateway-Hystrix","date":"2020-03-10T13:01:11.000Z","date_formatted":{"ll":"Mar 10, 2020","L":"03/10/2020","MM-DD":"03-10"},"updated":"2020-03-11T02:30:30.677Z","content":"此篇承接之前的博文SpringCloudGateway，建议从SpringCloud-Gateway看起\n接入Hystrixapplication.yml中配置如下：\n123456789101112131415161718spring:  cloud:    gateway:      routes:        - id: hystrix_route          uri: http://localhost:8081          filters:            - name: Hystrix              args:                name: HystrixCommend                #熔断时调用接口/fallback                fallbackUri: forward:/fallback          predicates:            - Path=/test/gethystrix:  metrics:    #设置超时时间2s，请求超过两秒就熔断    polling-interval-ms: 2000\n\n启动类上添加注解@RestController，并添加如下代码\n12345678910111213@RequestMapping(value = \"/fallback\")public Mono&lt;Map&lt;String, Object&gt;&gt; fallback(ServerWebExchange exchange, Throwable throwable) &#123;    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();    ServerHttpRequest request = exchange.getRequest();    result.put(\"path\", request.getPath().pathWithinApplication().value());    result.put(\"method\", request.getMethodValue());    if (null != throwable.getCause()) &#123;        result.put(\"message\", throwable.getCause().getMessage());    &#125; else &#123;        result.put(\"message\", throwable.getMessage());    &#125;    return Mono.just(result);&#125;\n\n新建一个小项目用于测试，编写接口\n123456789101112131415161718192021import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.TimeUnit;@RestController@RequestMapping(\"/test\")public class TestController &#123;    @GetMapping(\"/get\")    public String get() &#123;        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return \"ok\";    &#125;    &#125;\n\n测试结果如下：\n1&#123;\"path\":\"/fallback\",\"method\":\"GET\",\"message\":null&#125;\n\n没有返回ok说明已熔断保护，调用/fallback\n","plink":"https://blog.bugbak.com/2020/03/10/SpringCloudGateway-Hystrix/"},{"title":"SpringGateway-RateLimiter","date":"2020-03-09T20:01:11.000Z","date_formatted":{"ll":"Mar 9, 2020","L":"03/09/2020","MM-DD":"03-09"},"updated":"2020-03-11T02:30:18.917Z","content":"接入RateLimiter此篇承接之前的博文SpringCloudGateway，建议从SpringCloud-Gateway看起。限流是基于令牌桶算法和Redis实现的。\n核心参数这里解释几个核心参数。\nredis-rate-limiter.replenishRate：表示令牌的添加速率\nredis-rate-limiter.burstCapacity：表示桶的容积，设成0表示拒绝所以请求（官方文档是这样说的，但是我设置成0，启动报错提示：最小不能小于1，这里我只能呵呵。。。）\nredis-rate-limiter.requestedTokens：表示一个请求过了拿多少个令牌，默认是一个。\nkey-resolver：这个实现接口KeyResolver的类，用于解析出限流的关键字，比如host，url。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。\n示例代码首先我们先引入redis包，注意并不是只需要这个包，这是承接上一篇的Gateway，建议先看SpringCloudGateway。\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml中配置如下：\n123456789101112131415161718192021222324252627spring:  redis:    database: 0    host: 127.0.0.1    port: 6379    # 有密码填密码，没有密码不填    password: 123456    # 连接超时时间（ms)    timeout: 1000ms  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - name: RequestRateLimiter              args:              \t#获取自定义的KeyResolver实现类                key-resolver: \"#&#123;@userKeyResolver&#125;\"                #每秒钟均匀放入10个令牌，也就是100ms放一个令牌                redis-rate-limiter.replenishRate: 10                #令牌桶容积10                redis-rate-limiter.burstCapacity: 10                #每个请求获取一个令牌                redis-rate-limiter.requestedTokens: 1          predicates:            - Path=/get\n\n启动类中添加userkeyResolver类\n12345678910111213141516171819202122232425262728293031323334353637package com.bugbak.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.context.annotation.Bean;import reactor.core.publisher.Mono;@SpringBootApplicationpublic class GatewayApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GayutewayApplication.class, args);    &#125;    @Bean    KeyResolver userKeyResolver() &#123;        //获取请求中的请求参数user        return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(\"user\"));    &#125;    //      根据uri的路径限流，给大家参考//       public class UriKeyResolver  implements KeyResolver &#123;////            @Override//            public Mono&lt;String&gt; resolve(ServerWebExchange exchange) &#123;//                return Mono.just(exchange.getRequest().getURI().getPath());//            &#125;////        &#125;////        @Bean//        public UriKeyResolver uriKeyResolver() &#123;//            return new UriKeyResolver();//        &#125;&#125;\n\n欧克，即使这么简单，已经配置好了。\n测试限流测试没有key首先我们测试一下请求中没有user参数http://localhost:8080/get, 页面显示\n123456Whitelabel Error PageThis application has no configured error view, so you are seeing this as a fallback.Tue Mar 10 11:44:00 CST 2020[27f020a1] There was an unexpected error (type=Internal Server Error, status=500).value\n\n控制台报错\n123456789101112132020-03-10 11:44:00.148 ERROR 6248 --- [ctor-http-nio-3] a.w.r.e.AbstractErrorWebExceptionHandler : [27f020a1] 500 Server Error for HTTP GET \"/get\"java.lang.NullPointerException: value\tat java.util.Objects.requireNonNull(Objects.java:228) ~[na:1.8.0_162]\tSuppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: Error has been observed at the following site(s):\t|_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]\t|_ checkpoint ⇢ HTTP GET \"/get\" [ExceptionHandlingWebHandler]Stack trace:\t\tat java.util.Objects.requireNonNull(Objects.java:228) ~[na:1.8.0_162]\t\tat reactor.core.publisher.MonoJust.&lt;init&gt;(MonoJust.java:34) ~[reactor-core-3.3.0.RELEASE.jar:3.3.0.RELEASE]\t\tat reactor.core.publisher.Mono.just(Mono.java:560) ~[reactor-core-3.3.0.RELEASE.jar:3.3.0.RELEASE]\t\tat com.bugbak.gateway.GatewayApplication.lambda$userKeyResolver$0(GatewayApplication.java:18) ~[classes/:na]\n\n我先以为这是正常现象，就是这样被拦截了啊，但是后来发现是自己脑子瓦特了，任何报错都是有问题的，排除后修改如下\n12345@Bean  KeyResolver userKeyResolver() &#123;      //这里要处理为null的情况      return exchange -&gt; Mono.justOrEmpty(exchange.getRequest().getQueryParams().getFirst(\"user\"));  &#125;\n\n访问http://localhost:8080/get，正常显示，页面上是HTTP ERROR 403。\n测试有key接下来我们使用Jmeter测试一下令牌的拿取，我们使用11个线程，同时执行http://localhost:8080/get?user=aa，猜想应该有一个没有获取到令牌。测试结果如下：\n\n和预期一样，有一个访问失败，响应码是HTTP 429 - Too Many Requests。\n其他测试如果我们想修改是否拦截empty-key，以及拦截后的返回的状态码，可以参考下面配置\n12345678910spring:  cloud:    gateway:      filter:        request-rate-limiter:          #是否拦截空key，就是上面的userkeyResolver有没有解析到key，没有就是空key，默认值true拦截。          #这里我改成false，我测试的结果是没有user参数不进行限流，存在user参数则走限流策略          deny-empty-key: true          #拦截空key后，返回的code码，前提是上面拦截为true才生效          empty-key-status-code: 404\n\n最后我测试了一下，如果redis挂掉了，限流器会不会拒绝所有请求，答案是不会。redis挂了后将不进行限流，这也好理解，不能因为redis影响正常服务。\n最后另外还一个lua脚本request_rate_limiter.lua，在gateway包中就有，这也是实现限流的一个核心脚本，有兴趣的可以看看。\n参考https://cloud.spring.io/spring-cloud-gateway/reference/html/#the-redis-ratelimiter\n","plink":"https://blog.bugbak.com/2020/03/09/SpringCloudGateway-RateLimiter/"},{"title":"SpringCloudGateway","date":"2020-03-06T20:01:11.000Z","date_formatted":{"ll":"Mar 6, 2020","L":"03/06/2020","MM-DD":"03-06"},"updated":"2020-03-11T02:22:17.527Z","content":"搭建环境SpringBoot2.1.3，SpringBoot: 2.2.0.RELEASESpringCloud: Greenwich.SR2，SpringCloud: Hoxton.RELEASEJDK1.8.0_162Maven3.5.3\nSpring Cloud Gateway是什么Gateway是在Spring生态系统之上构建的API网关服务。说白了就是服务的出入口，请求都是从这进从这出。这里有三个概念。\nRoute（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由；Predicate（断言）：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由；Filter（过滤器）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改。工作原理\n客户端向Spring Cloud Gateway发出请求。如果网关处理映射器确定请求与路由匹配，则将其发送到网关Web处理器。该处理程序通过特定于请求的过滤器链来运行请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前和之后运行逻辑。所有“前置”过滤器逻辑均被执行。然后发出代理请求。发出代理请求后，将运行”后”过滤器逻辑。\n搭建一个Spring Cloud Gateway项目接下来我们一步步的搭建一个Spring Cloud Gateway项目。首先新建一个springboot项目项目名叫gateway。通过maven管理依赖，配置如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.9.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.bugbak&lt;/groupId&gt;    &lt;artifactId&gt;gateway&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;gateway&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Greenwich.SR2&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;/project&gt;\n\n然后等待依赖下载完毕，这里强调一下，依赖里不能出现spring-boot-starter-web，否者启动会报错，原因是Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行。它不能在传统的Servlet容器中或作为WAR构建时使用。\n配置路由的断言然后我们在application.yml文件中加入如下配置\n时间断言12345678910111213spring:  cloud:    gateway:      routes:      - id: route #路由器的名字，重复没有报错,不知为何        uri: http://httpbin.org #匹配成功后使用这个地址        predicates:          #在这个时间之后请求才有效          - After=2020-03-09T17:28:30.407+08:00[Asia/Shanghai]          #在这个时间之前请求才有效          - Before=2020-03-08T17:28:30.407+08:00[Asia/Shanghai]          #在这个时间之间请求才有效，前面值必须小于后面，否者报错          - Between=2020-03-08T17:28:30.407+08:00[Asia/Shanghai],2020-03-09T17:28:30.407+08:00[Asia/Shanghai]\n\nHttp参数断言12345678910111213141516171819#匹配cookie里面名字为 chocolate，值为符合ch.p正则表达式的值比如chap- Cookie=chocolate, ch.p#匹配头里面名字为X-Request-Id，值为符合\\d+正则表达式的比如这里是匹配数值- Header=X-Request-Id, \\d+#匹配头里面Host，符合下面的表达式，比如a.somehost.org- Host=**.somehost.org,**.anotherhost.org#sub可在ServerWebExchange.getAttributes()，ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUT，GatewayFilter- Host=&#123;sub&#125;.xxhost.com#匹配请求方式GET，POST都支持- Method=GET,POST#Map&lt;String, String&gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);#String segment = uriVariables.get(\"segment\");- Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;#匹配请求参数，这里有一个必须的参数，和一个可选的正则表达式参数，- Query=name#请求参数里有个参数名name，且他的值符合正则表达式deng.比如deng1- Query=name, deng.#匹配调用者的ip地址，24为子网掩码，注意如果调用者使用了代理，这个值就是代理ip地址，可以使用X-Forwarded-For解决这个问题- RemoteAddr=127.0.0.1/24\n\n权重断言123456789101112  #权重配置，有两个参数一个是group，如下group1和group2,以及weight是int型数值。  #如下配置就是80%的走http://httpbin1.org,20%的走http://httpbin2.org- id: weight_high  uri: http://httpbin1.org  predicates:    - Weight=group1, 8    - Path=/post- id: weight_low  uri: http://httpbin2.org  predicates:    - Weight=group1, 2    - Path=/get\n\n以上皆测试所得，这里重点阐述一下权重配置。就我测试结果观察。就是有80%几率走httpbin1，不管里面是否会匹配，比如我配置的路径是/post, 我请求的路径是/get，他还是会走httpbin1。如果我在weight_high，weight_low中间再穿插一个规则，也是符合的请求的，那么百分百不走weight_low。给我的感觉就是由上而下进行执行直到匹配上规则，走到weight_high的时候判断一下80%的概率是否执行，不执行就往下走，而不是跳到weight_low执行。\n各位小伙伴可以自行测试，如果没有修改端口的话，就执行http://localhost:8080/get 就可以测试了， 这里有个小坑，大家注意一下，如果报错如下，大家看是否spring-boot-starter-parent版本高于2.2.0,如果高于，就把版本降低到这个版本以下。\n12345678910112020-03-08 20:37:08.334 ERROR 7812 --- [ctor-http-nio-3] reactor.netty.http.server.HttpServer     : [id: 0x3e6a4c38, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:51078] java.lang.NoSuchMethodError: reactor.netty.http.client.HttpClient.chunkedTransfer(Z)Lreactor/netty/http/client/HttpClient;\tat org.springframework.cloud.gateway.filter.NettyRoutingFilter.filter(NettyRoutingFilter.java:125) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat org.springframework.cloud.gateway.handler.FilteringWebHandler$GatewayFilterAdapter.filter(FilteringWebHandler.java:138) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat org.springframework.cloud.gateway.filter.OrderedGatewayFilter.filter(OrderedGatewayFilter.java:44) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat org.springframework.cloud.gateway.handler.FilteringWebHandler$DefaultGatewayFilterChain.lambda$filter$0(FilteringWebHandler.java:118) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\n\n\n\n配置路由的过滤器AddRequestHeader这里我新建了一个application-dev.yml，原来的application.yml中加入配置\n123spring:  profiles:    active: dev\n\ndev配置如下:\n1234spring:  cloud:    gateway:      routes:\n\n我在测试是否存在覆盖的时候，发现配置上面这种情况。application.yml中的routes全部失效。这点的确没有想到。目前的结论是无法分文件配置，只能写在一个文件里面。\n123456789101112131415spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          predicates:            - Path=/get        - id: route          uri: http://httpbin.org          filters:            #添加请求头X-Request-re:blue            - AddRequestHeader=X-Request-red, blue          predicates:            - Path=/get\n\n上图我再次测试了是不是按顺序进行匹配的，测试结果是没有加请求头X-Request-red，所以就是上面说的，匹配到，就结束。\n还有一种就是predicates中设置的变量filters中可以使用如下：\n1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:          #添加请求头参数red:blue-&#123;segment&#125;，segment是取去请求Path里面的值            - AddRequestHeader=X-Request-red, blue-&#123;segment&#125;          predicates:            - Path=/anything/&#123;segment&#125;\n\n这种情况测试没有成功，这下我有经验了，我将spring-cloud-dependencies版本升级了了，spring-boot-starter-parent也升级了，配置如下：\n1234567&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&lt;version&gt;Hoxton.RELEASE&lt;/version&gt;\n\n结果他成功了，真是不让人不省心啊。。。。然后我趁热打铁测了一下上面覆盖的问题，发现问题还是存在application.yml中的routes还是全部失效。\nAddRequestParameter1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            #添加请求参数red=blue-&#123;segment&#125;，segment是取去请求Path里面的值            - AddRequestParameter=red, blue-&#123;segment&#125;          predicates:            - Path=/anything/&#123;segment&#125;\n\nAddResponseHeader1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            #添加响应头red=blue-&#123;segment&#125;，segment是取去请求Path里面的值            - AddResponseHeader=X-Response-Red, Blue          predicates:            - Path=/anything/&#123;segment&#125;\n\nDedupeResponseHeader这个就是干掉重复的响应头，有人肯定就会迷惑，怎么会出现重复的响应头，刚好本人在开发中遇到过这个问题，就是在解决跨域问题，我程序里面加了一个Access-Control-Allow-Origin:*，然后运维在nginx上也加了一个，所以出现了两个一样的响应头。既然有两个，肯定是有保留哪一个的问题，这个提供3种RETAIN_FIRST（这个是默认项，保留第一个），RETAIN_LAST(保留最后一个)，RETAIN_UNIQUE(保留唯一的)\n1234567891011121314spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Response-Red, Blue1            - AddResponseHeader=X-Response-Red, Blue2            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue4          predicates:            - Path=/anything/&#123;segment&#125;\n\n我们先给他添一下响应头，响应头结果如下\n123456789101112HTTP/1.1 200 OKX-Response-Red: Blue1X-Response-Red: Blue2X-Response-Yellow: Blue3X-Response-Yellow: Blue3X-Response-Yellow: Blue4Date: Sun, 08 Mar 2020 16:12:42 GMTContent-Type: application/jsonContent-Length: 652Server: gunicorn/19.9.0Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true\n\n这个时候我们加入DedupeResponseHeader\n12345678910111213141516spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Response-Red, Blue1            - AddResponseHeader=X-Response-Red, Blue2            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue4            - DedupeResponseHeader=X-Response-Red,RETAIN_LAST            - DedupeResponseHeader=X-Response-Yellow,RETAIN_UNIQUE          predicates:            - Path=/anything/&#123;segment&#125;\n\n运行结果如下\n12345678910HTTP/1.1 200 OKDate: Sun, 08 Mar 2020 16:19:52 GMTContent-Type: application/jsonContent-Length: 652Server: gunicorn/19.9.0Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: trueX-Response-Yellow: Blue3X-Response-Yellow: Blue4X-Response-Red: Blue2\n\n结果一目了然，X-Response-Red保留最后就是Blue2,X-Response-Yellow保留唯一的就是删掉了重复的Blue3，还有一种写法，如果都采用默认策略，可以直接这样写，两个响应头之间用空格隔开。\n1- DedupeResponseHeader=X-Response-Red X-Response-Yellow\n\nCircuitBreaker首先解释一下，这个玩意叫断路器。这里支持两种Hystrix和Resilience4J。官方文档推荐Resilience4J，说Hystrix现在被标记为只维护了。然后我去招聘网上在深圳收了一下Resilience4J，一家都没有…..然后又搜了一下Hystrix，就只有5家……实话说我也只对Hystrix眼熟，所以这里我们主要讨论一下Hystrix。由于篇幅原因，我在另一篇博文里面专门讲解。\nMapRequestHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddRequestHeader=X-Request-1, 1            - AddRequestHeader=X-Request-2, 2            - MapRequestHeader=X-Request-1,X-Request-2          predicates:            - Path=/anything/&#123;segment&#125;\n\n说白了就是复制一个和X-Request-1一样的值的请求头X-Request-2，如果XRequest-2之前就已经存在，就把原来的值包括进去。记住是复制一个，原来的头还在那里，看下图的结果就明白了\n12345678910111213141516171819202122&#123;  \"args\": &#123;&#125;,   \"data\": \"\",   \"files\": &#123;&#125;,   \"form\": &#123;&#125;,   \"headers\": &#123;    \"Accept\": \"*/*\",     \"Accept-Encoding\": \"gzip,deflate\",     \"Content-Length\": \"0\",     \"Forwarded\": \"proto=http;host=\\\"localhost:8080\\\";for=\\\"127.0.0.1:61222\\\"\",     \"Host\": \"httpbin.org\",     \"User-Agent\": \"Apache-HttpClient/4.5.8 (Java/11.0.3)\",     \"X-Amzn-Trace-Id\": \"Root=1-5e65bea6-8c228e8c8017cd5df1ff75a5\",     \"X-Forwarded-Host\": \"localhost:8080\",     \"X-Request-1\": \"1\",     \"X-Request-2\": \"2,1\"  &#125;,   \"json\": null,   \"method\": \"GET\",   \"origin\": \"127.0.0.1, 113.57.247.0\",   \"url\": \"http://localhost:8080/anything/haha\"&#125;\n\n然后我测试了一下filters是不是有顺序的，将MapRequestHeader移到最上面，结果是没有生效，所以filters是按顺序执行的。然后我测试了之前的DedupeResponseHeader放在上面，发现没有影响，我猜他每个部分有一个整体顺序，每个部分的内部是按配置顺序来，反正按照逻辑顺序写就对了。\nPrefixPath12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - PrefixPath=/anything          predicates:            - Path=/get\n\n把匹配到的路径加一个前缀/anything，http://localhost:8080/get的结果就变成了http://localhost:8080/anything/get\nPreserveHostHeader12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - PreserveHostHeader          predicates:            - Path=/get\n\n没加PreserveHostHeader\n123456789101112131415&#123;  \"args\": &#123;&#125;,   \"headers\": &#123;    \"Accept\": \"*/*\",     \"Accept-Encoding\": \"gzip,deflate\",     \"Content-Length\": \"0\",     \"Forwarded\": \"proto=http;host=\\\"localhost:8080\\\";for=\\\"127.0.0.1:62728\\\"\",     \"Host\": \"httpbin.org\",     \"User-Agent\": \"Apache-HttpClient/4.5.8 (Java/11.0.3)\",     \"X-Amzn-Trace-Id\": \"Root=1-5e65c53a-6e62e57803de635ad7a1795c\",     \"X-Forwarded-Host\": \"localhost:8080\"  &#125;,   \"origin\": \"127.0.0.1, 113.57.247.0\",   \"url\": \"http://localhost:8080/get\"&#125;\n\n加了PreserveHostHeader\n123456789101112131415&#123;  \"args\": &#123;&#125;,   \"headers\": &#123;    \"Accept\": \"*/*\",     \"Accept-Encoding\": \"gzip,deflate\",     \"Content-Length\": \"0\",     \"Forwarded\": \"proto=http;host=\\\"localhost:8080\\\";for=\\\"127.0.0.1:62634\\\"\",     \"Host\": \"localhost\",     \"User-Agent\": \"Apache-HttpClient/4.5.8 (Java/11.0.3)\",     \"X-Amzn-Trace-Id\": \"Root=1-5e65c4fe-aa95f72094a2cfa02e0408e0\",     \"X-Forwarded-Host\": \"localhost:8080\"  &#125;,   \"origin\": \"127.0.0.1, 113.57.247.0\",   \"url\": \"http://localhost:8080/get\"&#125;\n\n差别在Host请求头上，PreserveHostHeader没有参数，意思是保留Host头，加了就是用请求url上的host，不加就是路由配置uri里面host\nRequestRateLimiter限流这一块没有快捷配置，我们单独拿出来讲解。\nRedirectTo重定向，有两个参数一个status，一个url。status对应是300系列的重定向状态码。下图配置就是返回一个状态码为302，然后响应头里面有一个Location: https://baidu.com，说白了就是跳转到百度\n12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - RedirectTo=302,https://baidu.com          predicates:            - Path=/get\n\nRemoveRequestHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddRequestHeader=X-Request-1, 1            #如果存在则移除请求头X-Request-1            - RemoveRequestHeader=X-Request-1          predicates:            - Path=/get\n\nRemoveResponseHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Request-1, 1            #如果存在则移除响应头X-Request-1            - RemoveRequestHeader=X-Request-1          predicates:            - Path=/get\n\n如果有一个公共的响应头，里面的值过于敏感，不能显示给调用者，然后一个个的添加过滤很显然不符合实际，这个时候有一个全局过滤default-filters。\n123456789101112spring:  cloud:    gateway:      default-filters:        - RemoveResponseHeader=X-Response-Red      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Response-Red, Blue1          predicates:            - Path=/get\n\nRemoveRequestParameter1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            #添加请求头移除请求参数name            - RemoveRequestParameter=name          predicates:            - Path=/get\n\nRewritePath12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - RewritePath=/red(?&lt;segment&gt;/?.*), $\\&#123;segment&#125;          predicates:            - Path=/anything/**\n\n按照正则表达式重写路径，RewritePath有两个参数第一个是正则表达式，第二个是替换的参数。上面的配置就是访问http://localhost:8080/anything/red/blue，被替换成http://localhost:8080/anything/blue。\nRewriteLocationResponseHeader还没测试貌似有点绕，先贴个官方示例\n12345678spring:  cloud:    gateway:      routes:      - id: rewritelocationresponseheader_route        uri: http://example.org        filters:        - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, ,\n\nRewriteResponseHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          predicates:            - Path=/anything/**          filters:            - AddResponseHeader=X-Response-Red, password=123            #修改响应头里面的值，以下三个变量分别代表：响应头名字、正则表达示匹配内容、替换上的值            - RewriteResponseHeader=X-Response-Red, password=[^&amp;]+, password=***\n\nSaveSession12345678910spring:  cloud:    gateway:      routes:      - id: save_session        uri: https://example.org        predicates:        - Path=/foo/**        filters:        - SaveSession\n\nSecureHeaders添加一响应头，默认如下\nX-Xss-Protection:1 (mode=block)Strict-Transport-Security (max-age=631138519)X-Frame-Options (DENY)X-Content-Type-Options (nosniff)Referrer-Policy (no-referrer)Content-Security-Policy (default-src &#39;self&#39; https:; font-src &#39;self&#39; https: data:; img-src &#39;self&#39; https: data:; object-src &#39;none&#39;; script-src https:; style-src &#39;self&#39; https: &#39;unsafe-inline)&#39;X-Download-Options (noopen)X-Permitted-Cross-Domain-Policies (none)SetPath12345678910spring:  cloud:    gateway:      routes:      - id: setpath_route        uri: https://example.org        predicates:        - Path=/red/&#123;segment&#125;        filters:        - SetPath=/&#123;segment&#125;\n\nSetRequestHeader12345678spring:  cloud:    gateway:      routes:      - id: setrequestheader_route        uri: https://example.org        filters:        - SetRequestHeader=X-Request-Red, Blue\n\n12345678910spring:  cloud:    gateway:      routes:      - id: setrequestheader_route        uri: https://example.org        predicates:        - Host: &#123;segment&#125;.myhost.org        filters:        - SetRequestHeader=foo, bar-&#123;segment&#125;\n\nSetResponseHeader12345678spring:  cloud:    gateway:      routes:      - id: setresponseheader_route        uri: https://example.org        filters:        - SetResponseHeader=X-Response-Red, Blue\n\n12345678910spring:  cloud:    gateway:      routes:      - id: setresponseheader_route        uri: https://example.org        predicates:        - Host: &#123;segment&#125;.myhost.org        filters:        - SetResponseHeader=foo, bar-&#123;segment&#125;\n\nSetStatus123456789101112spring:  cloud:    gateway:      routes:      - id: setstatusstring_route        uri: https://example.org        filters:        - SetStatus=BAD_REQUEST      - id: setstatusint_route        uri: https://example.org        filters:        - SetStatus=401\n\n123456spring:  cloud:    gateway:      set-status:      #可以将原来的响应码放在这个头里，如果正常响应则original-http-status: [200]        original-status-header-name: original-http-status\n\nStripPrefix12345678910spring:  cloud:    gateway:      routes:      - id: nameRoot        uri: https://nameservice        predicates:        - Path=/name/**        filters:        - StripPrefix=2\n\n通过网关/name/blue/red发出请求时，请求路径变成/red\nRetry123456789101112131415161718192021222324252627spring:  cloud:    gateway:      routes:        - id: route          uri: http://localhost:8081          predicates:            - Path=/test/get          filters:            - name: Retry              args:                #重试三次，加上第一次一共四次                retries: 3                #响应码为502进行重试                status: 502                #请求方法是GET，或者Post才重试                methods: GET,POST                #一系列响应码就是5开头就是服异常，不能写数值，与status同时配置，status失效 #INFORMATIONAL(1),SUCCESSFUL(2),REDIRECTION(3),CLIENT_ERROR(4),SERVER_ERROR(5);                series: CLIENT_ERROR                #应该重试的异常列表，我这样配置没有生效                exceptions: java.io.IOException                #下面几个参数没搞明白                backoff:                  firstBackoff: 10ms                  maxBackoff: 50ms                  factor: 2                  basedOnPreviousValue: false\n\n如果直接开启默认配置如下，一般开启默认就行了- Retry\nretries: Three timesseries: 5XX seriesmethods: GET methodexceptions: IOException and TimeoutExceptionbackoff: disabledRequestSize现在上传数据大小,默认是5MB，超过了会提示HTTP/1.1 413 Request Entity Too LargeerrorMessage: Request size is larger than permissible limit. Request size is 1.4 MB where permissible limit is 1.0 kBModifyRequestBody这个只能用JAVA DSL配置，如下示例ModifyResponseBody这个只能用JAVA DSL配置，如下示例default-filters默认过滤对全局生效，之前的应都支持总结这次给我最大的感悟就是，在引入包的时候，版本一定要统一！一定要统一！一定要统一！重要的事情说3遍，2.2.x就对应2.2.x，千万被跨大版本，要不然各种坑！\n参考https://spring.io/guides/gs/gateway/\nhttps://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-starter\n","plink":"https://blog.bugbak.com/2020/03/06/SpringCloudGateway/"},{"title":"CAP理论","date":"2020-03-01T20:01:11.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-11T02:22:08.745Z","content":"什么是CAP理论在理论计算机科学中，CAP理论指出，分布式数据存储（这里要注意是分布式储存）不可能同时提供以下三个保证中的两个以上：\n分区容错性（Partition tolerance）我觉得先讲P对于理解下面的CA会好一点。因为我觉得没有P就没有下面CA的问题。首先我们先拆开理解什么叫分区，什么叫容错性。\n分区：就是在一个分布式系统里面，节点组成的网络本来应该是连通的，然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。容错性：当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了，这时分区就没有容错性。提高分区容错性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里，就有了容错性。所以结合起来分区容错性，就是有联系的多个节点之间断开了，且都保存同一份数据 ，而且两个分区的节点都还要是正常运行的。\n一致性（Consistency）首先注意该一致性与ACID 数据库事务中保证的一致性完全不同。上面我对P的讲解的，就好理解了一致性就是所有节点在同一时间的数据完全一致。比如两个节点node1，node2，他们都有同一个变量a=0，当我修改node1数据a=1后，访问node2也返回的a=1。一致性又分为两类：\n强一致性：复制数据是同步的。弱一致性：复制数据是异步的。这里一致性指的是强一致性。\n可用性（Availability）首先强调一下我们日常谈论到的“高可用性“是指停机时间，比如99.999%就是说我全年只停机365x24x60x(1-0.99999)=5.256分钟，这个”高可用性“和这里的可用性完全不是同一个概念。CAP中的A指的是系统中无故障的[数据库]节点收到的每个请求都必须产生[无错误]响应”。\n如何理解CAP定理只能满足两项分布式存储中，是不可能保证网络不出问题的，所以P是肯定满足的。如下图，G1和G2是两个节点，两个都维护这一个数据v0。\n\n这个时候client修改v0为v1。\n保证一致性，这个时候G1就应该把V1同步给G2，可是他们之间网络出问题了，传不过去，这个时候怎么办？报错，不给处理，违背了可用性。保证可用性，这个是时候G1只把自己的数据修改为V1了，没管G2，返回正常。这个时候client再去访问G2返回的是v0，很明显数据不一致了，违背了一致性。所以由上面的例子分布式CAP只能满足两项，要么CP，要么AP。\n参考https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/    \nhttps://www.zhihu.com/question/54105974\nhttps://dzone.com/articles/understanding-the-cap-theorem\n","plink":"https://blog.bugbak.com/2020/03/01/CAP理论/"},{"title":".gitignore语法规范","date":"2020-02-28T10:47:12.000Z","date_formatted":{"ll":"Feb 28, 2020","L":"02/28/2020","MM-DD":"02-28"},"updated":"2020-03-11T02:22:39.785Z","content":".gitignore为何物？从名字就可以看出来，就是在git里面忽略一些文件，比如：idea打开项目后的.idea文件。这些文件没有必要上传到git仓库，而且每个人idea的配置可能还不一样，pull下来别人的配置还可能会导致一些谜之问题。这时候聪明的同学肯定就会说，把不需要的文件不add到git中不就可以了吗？没错，让git不去管理这些文件的确是可以的，但人都会犯错，不保证每个人都不会将这些文件提交上去，但是被gitignore忽视的这些文件，是永远都提交不上去的，就可以化解人为的操作失误。\n如何使用.gitignore在项目的根目录里面也就是.git文件夹的同级目录下创建一个.gitignore文件，看不见.git文件夹的，打开显示隐藏文件夹。注意.gitignore这个名字已经包括了名称和后缀，千万别创建了一个.gitignore.txt文件。创建好之后我们按照官方给定的语法进行配置，就可以指定忽略哪些文件或文件夹。\n.ignore语法示例文字都是苍白的，下面我们来实操一波，以下都是我实测所得，如有纰漏，欢迎评论指出！\n注：配图中黄色是被git忽略的\n12345678# *用来匹配零个或多个字符，忽略所有.txt后缀的文件*.txt# 如果想让a.txt不被忽略，可以加上！注意：顺序和上面颠倒会失效!a.txt# 忽略所有a.txt,b.txt文件，不包括ab.txt，[]用来匹配括号内任意一个字符，[0-9]匹配0到9的数[ab].txt# 用?配单个字符，忽略a.txt,不会略ab.txt?.txt\n\n123#忽略所有doc文件夹里面所有，不管doc是否为一级二级，这里的一级指的是和.gitignore同级，这两个效果一致docdoc/\n\n\n12# 忽略doc文件夹下所有，不包括/dom/doc，也就是它作为一级目录下递归所有/doc\n\n\n12# 忽略doc作为一级目录下的，不包括/dom/doc/a.txt,不包括子目录/doc/img/a.txtdoc/*.txt\n\n\n12# 忽略doc作为一级目录下的，二级目录里面的txt文件，不包括第三级目录，额。。。懵逼了，还是看图吧，一图胜千言doc/*/*.txt\n\n\n12# 忽略doc作为一级目录下的所有.txt文件doc/**/*.txt\n\n\n补充说明使用idea开发项目的小伙伴可以下载插件.ignore，被忽略的文件或者文件夹会改变颜色。这样就可以很轻松的辨别自己的配置是否成功。\n参考https://git-scm.com/docs/gitignore\n","plink":"https://blog.bugbak.com/2020/02/28/gitignore语法规范/"},{"title":"About Me","date":"2019-07-20T09:43:19.000Z","date_formatted":{"ll":"Jul 20, 2019","L":"07/20/2019","MM-DD":"07-20"},"updated":"2020-03-05T11:23:20.968Z","content":"首先告诉你一个不幸的消息，你将会在这个页面失去1分钟的青春。但是！莫慌~通过阅读鄙人的blog你可以节省至少X小时的青春嗯 ？ X？？你细品~有人可能会问鄙人为什么决定写blog？问的好！鄙人在互联网搬砖也有些年头了最明显的不是肌肉变发达了而是头发少了咳咳~是记忆力消退没错东西写出来肯定就不会丢了啊这时候肯定就有狼人跳出来指着我的鼻子说数据库炸了不久丢了吗？说的好，所以我。。。一拳打爆你的狗头哦~开个玩笑~最后如果我的输出能让大家有所收获那可真是令人开心哦~哈哈哈哈哈~\n","plink":"https://blog.bugbak.com/about/me/"}]