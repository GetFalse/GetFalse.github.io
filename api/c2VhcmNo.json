[{"title":"SpringCloudGateway-Hystrix","date":"2020-03-10T13:01:11.000Z","date_formatted":{"ll":"Mar 10, 2020","L":"03/10/2020","MM-DD":"03-10"},"updated":"2020-03-11T02:30:30.677Z","content":"此篇承接之前的博文SpringCloudGateway，建议从SpringCloud-Gateway看起\n接入Hystrixapplication.yml中配置如下：\n123456789101112131415161718spring:  cloud:    gateway:      routes:        - id: hystrix_route          uri: http://localhost:8081          filters:            - name: Hystrix              args:                name: HystrixCommend                #熔断时调用接口/fallback                fallbackUri: forward:/fallback          predicates:            - Path=/test/gethystrix:  metrics:    #设置超时时间2s，请求超过两秒就熔断    polling-interval-ms: 2000\n\n启动类上添加注解@RestController，并添加如下代码\n12345678910111213@RequestMapping(value = \"/fallback\")public Mono&lt;Map&lt;String, Object&gt;&gt; fallback(ServerWebExchange exchange, Throwable throwable) &#123;    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();    ServerHttpRequest request = exchange.getRequest();    result.put(\"path\", request.getPath().pathWithinApplication().value());    result.put(\"method\", request.getMethodValue());    if (null != throwable.getCause()) &#123;        result.put(\"message\", throwable.getCause().getMessage());    &#125; else &#123;        result.put(\"message\", throwable.getMessage());    &#125;    return Mono.just(result);&#125;\n\n新建一个小项目用于测试，编写接口\n123456789101112131415161718192021import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.TimeUnit;@RestController@RequestMapping(\"/test\")public class TestController &#123;    @GetMapping(\"/get\")    public String get() &#123;        try &#123;            TimeUnit.SECONDS.sleep(3);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return \"ok\";    &#125;    &#125;\n\n测试结果如下：\n1&#123;\"path\":\"/fallback\",\"method\":\"GET\",\"message\":null&#125;\n\n没有返回ok说明已熔断保护，调用/fallback\n","plink":"https://blog.bugbak.com/2020/03/10/SpringCloudGateway-Hystrix/"},{"title":"SpringGateway-RateLimiter","date":"2020-03-09T20:01:11.000Z","date_formatted":{"ll":"Mar 9, 2020","L":"03/09/2020","MM-DD":"03-09"},"updated":"2020-03-11T02:30:18.917Z","content":"接入RateLimiter此篇承接之前的博文SpringCloudGateway，建议从SpringCloud-Gateway看起。限流是基于令牌桶算法和Redis实现的。\n核心参数这里解释几个核心参数。\nredis-rate-limiter.replenishRate：表示令牌的添加速率\nredis-rate-limiter.burstCapacity：表示桶的容积，设成0表示拒绝所以请求（官方文档是这样说的，但是我设置成0，启动报错提示：最小不能小于1，这里我只能呵呵。。。）\nredis-rate-limiter.requestedTokens：表示一个请求过了拿多少个令牌，默认是一个。\nkey-resolver：这个实现接口KeyResolver的类，用于解析出限流的关键字，比如host，url。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。\n示例代码首先我们先引入redis包，注意并不是只需要这个包，这是承接上一篇的Gateway，建议先看SpringCloudGateway。\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;\n\napplication.yml中配置如下：\n123456789101112131415161718192021222324252627spring:  redis:    database: 0    host: 127.0.0.1    port: 6379    # 有密码填密码，没有密码不填    password: 123456    # 连接超时时间（ms)    timeout: 1000ms  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - name: RequestRateLimiter              args:              \t#获取自定义的KeyResolver实现类                key-resolver: \"#&#123;@userKeyResolver&#125;\"                #每秒钟均匀放入10个令牌，也就是100ms放一个令牌                redis-rate-limiter.replenishRate: 10                #令牌桶容积10                redis-rate-limiter.burstCapacity: 10                #每个请求获取一个令牌                redis-rate-limiter.requestedTokens: 1          predicates:            - Path=/get\n\n启动类中添加userkeyResolver类\n12345678910111213141516171819202122232425262728293031323334353637package com.bugbak.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.context.annotation.Bean;import reactor.core.publisher.Mono;@SpringBootApplicationpublic class GatewayApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GayutewayApplication.class, args);    &#125;    @Bean    KeyResolver userKeyResolver() &#123;        //获取请求中的请求参数user        return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(\"user\"));    &#125;    //      根据uri的路径限流，给大家参考//       public class UriKeyResolver  implements KeyResolver &#123;////            @Override//            public Mono&lt;String&gt; resolve(ServerWebExchange exchange) &#123;//                return Mono.just(exchange.getRequest().getURI().getPath());//            &#125;////        &#125;////        @Bean//        public UriKeyResolver uriKeyResolver() &#123;//            return new UriKeyResolver();//        &#125;&#125;\n\n欧克，即使这么简单，已经配置好了。\n测试限流测试没有key首先我们测试一下请求中没有user参数http://localhost:8080/get, 页面显示\n123456Whitelabel Error PageThis application has no configured error view, so you are seeing this as a fallback.Tue Mar 10 11:44:00 CST 2020[27f020a1] There was an unexpected error (type=Internal Server Error, status=500).value\n\n控制台报错\n123456789101112132020-03-10 11:44:00.148 ERROR 6248 --- [ctor-http-nio-3] a.w.r.e.AbstractErrorWebExceptionHandler : [27f020a1] 500 Server Error for HTTP GET \"/get\"java.lang.NullPointerException: value\tat java.util.Objects.requireNonNull(Objects.java:228) ~[na:1.8.0_162]\tSuppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: Error has been observed at the following site(s):\t|_ checkpoint ⇢ org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter [DefaultWebFilterChain]\t|_ checkpoint ⇢ HTTP GET \"/get\" [ExceptionHandlingWebHandler]Stack trace:\t\tat java.util.Objects.requireNonNull(Objects.java:228) ~[na:1.8.0_162]\t\tat reactor.core.publisher.MonoJust.&lt;init&gt;(MonoJust.java:34) ~[reactor-core-3.3.0.RELEASE.jar:3.3.0.RELEASE]\t\tat reactor.core.publisher.Mono.just(Mono.java:560) ~[reactor-core-3.3.0.RELEASE.jar:3.3.0.RELEASE]\t\tat com.bugbak.gateway.GatewayApplication.lambda$userKeyResolver$0(GatewayApplication.java:18) ~[classes/:na]\n\n我先以为这是正常现象，就是这样被拦截了啊，但是后来发现是自己脑子瓦特了，任何报错都是有问题的，排除后修改如下\n12345@Bean  KeyResolver userKeyResolver() &#123;      //这里要处理为null的情况      return exchange -&gt; Mono.justOrEmpty(exchange.getRequest().getQueryParams().getFirst(\"user\"));  &#125;\n\n访问http://localhost:8080/get，正常显示，页面上是HTTP ERROR 403。\n测试有key接下来我们使用Jmeter测试一下令牌的拿取，我们使用11个线程，同时执行http://localhost:8080/get?user=aa，猜想应该有一个没有获取到令牌。测试结果如下：\n\n和预期一样，有一个访问失败，响应码是HTTP 429 - Too Many Requests。\n其他测试如果我们想修改是否拦截empty-key，以及拦截后的返回的状态码，可以参考下面配置\n12345678910spring:  cloud:    gateway:      filter:        request-rate-limiter:          #是否拦截空key，就是上面的userkeyResolver有没有解析到key，没有就是空key，默认值true拦截。          #这里我改成false，我测试的结果是没有user参数不进行限流，存在user参数则走限流策略          deny-empty-key: true          #拦截空key后，返回的code码，前提是上面拦截为true才生效          empty-key-status-code: 404\n\n最后我测试了一下，如果redis挂掉了，限流器会不会拒绝所有请求，答案是不会。redis挂了后将不进行限流，这也好理解，不能因为redis影响正常服务。\n最后另外还一个lua脚本request_rate_limiter.lua，在gateway包中就有，这也是实现限流的一个核心脚本，有兴趣的可以看看。\n参考https://cloud.spring.io/spring-cloud-gateway/reference/html/#the-redis-ratelimiter\n","plink":"https://blog.bugbak.com/2020/03/09/SpringCloudGateway-RateLimiter/"},{"title":"SpringCloudGateway","date":"2020-03-06T20:01:11.000Z","date_formatted":{"ll":"Mar 6, 2020","L":"03/06/2020","MM-DD":"03-06"},"updated":"2020-03-11T02:22:17.527Z","content":"搭建环境SpringBoot2.1.3，SpringBoot: 2.2.0.RELEASESpringCloud: Greenwich.SR2，SpringCloud: Hoxton.RELEASEJDK1.8.0_162Maven3.5.3\nSpring Cloud Gateway是什么Gateway是在Spring生态系统之上构建的API网关服务。说白了就是服务的出入口，请求都是从这进从这出。这里有三个概念。\nRoute（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由；Predicate（断言）：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由；Filter（过滤器）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改。工作原理\n客户端向Spring Cloud Gateway发出请求。如果网关处理映射器确定请求与路由匹配，则将其发送到网关Web处理器。该处理程序通过特定于请求的过滤器链来运行请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前和之后运行逻辑。所有“前置”过滤器逻辑均被执行。然后发出代理请求。发出代理请求后，将运行”后”过滤器逻辑。\n搭建一个Spring Cloud Gateway项目接下来我们一步步的搭建一个Spring Cloud Gateway项目。首先新建一个springboot项目项目名叫gateway。通过maven管理依赖，配置如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.9.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.bugbak&lt;/groupId&gt;    &lt;artifactId&gt;gateway&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;gateway&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Greenwich.SR2&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;/project&gt;\n\n然后等待依赖下载完毕，这里强调一下，依赖里不能出现spring-boot-starter-web，否者启动会报错，原因是Spring Cloud Gateway需要Spring Boot和Spring Webflux提供的Netty运行。它不能在传统的Servlet容器中或作为WAR构建时使用。\n配置路由的断言然后我们在application.yml文件中加入如下配置\n时间断言12345678910111213spring:  cloud:    gateway:      routes:      - id: route #路由器的名字，重复没有报错,不知为何        uri: http://httpbin.org #匹配成功后使用这个地址        predicates:          #在这个时间之后请求才有效          - After=2020-03-09T17:28:30.407+08:00[Asia/Shanghai]          #在这个时间之前请求才有效          - Before=2020-03-08T17:28:30.407+08:00[Asia/Shanghai]          #在这个时间之间请求才有效，前面值必须小于后面，否者报错          - Between=2020-03-08T17:28:30.407+08:00[Asia/Shanghai],2020-03-09T17:28:30.407+08:00[Asia/Shanghai]\n\nHttp参数断言12345678910111213141516171819#匹配cookie里面名字为 chocolate，值为符合ch.p正则表达式的值比如chap- Cookie=chocolate, ch.p#匹配头里面名字为X-Request-Id，值为符合\\d+正则表达式的比如这里是匹配数值- Header=X-Request-Id, \\d+#匹配头里面Host，符合下面的表达式，比如a.somehost.org- Host=**.somehost.org,**.anotherhost.org#sub可在ServerWebExchange.getAttributes()，ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUT，GatewayFilter- Host=&#123;sub&#125;.xxhost.com#匹配请求方式GET，POST都支持- Method=GET,POST#Map&lt;String, String&gt; uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);#String segment = uriVariables.get(\"segment\");- Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;#匹配请求参数，这里有一个必须的参数，和一个可选的正则表达式参数，- Query=name#请求参数里有个参数名name，且他的值符合正则表达式deng.比如deng1- Query=name, deng.#匹配调用者的ip地址，24为子网掩码，注意如果调用者使用了代理，这个值就是代理ip地址，可以使用X-Forwarded-For解决这个问题- RemoteAddr=127.0.0.1/24\n\n权重断言123456789101112  #权重配置，有两个参数一个是group，如下group1和group2,以及weight是int型数值。  #如下配置就是80%的走http://httpbin1.org,20%的走http://httpbin2.org- id: weight_high  uri: http://httpbin1.org  predicates:    - Weight=group1, 8    - Path=/post- id: weight_low  uri: http://httpbin2.org  predicates:    - Weight=group1, 2    - Path=/get\n\n以上皆测试所得，这里重点阐述一下权重配置。就我测试结果观察。就是有80%几率走httpbin1，不管里面是否会匹配，比如我配置的路径是/post, 我请求的路径是/get，他还是会走httpbin1。如果我在weight_high，weight_low中间再穿插一个规则，也是符合的请求的，那么百分百不走weight_low。给我的感觉就是由上而下进行执行直到匹配上规则，走到weight_high的时候判断一下80%的概率是否执行，不执行就往下走，而不是跳到weight_low执行。\n各位小伙伴可以自行测试，如果没有修改端口的话，就执行http://localhost:8080/get 就可以测试了， 这里有个小坑，大家注意一下，如果报错如下，大家看是否spring-boot-starter-parent版本高于2.2.0,如果高于，就把版本降低到这个版本以下。\n12345678910112020-03-08 20:37:08.334 ERROR 7812 --- [ctor-http-nio-3] reactor.netty.http.server.HttpServer     : [id: 0x3e6a4c38, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:51078] java.lang.NoSuchMethodError: reactor.netty.http.client.HttpClient.chunkedTransfer(Z)Lreactor/netty/http/client/HttpClient;\tat org.springframework.cloud.gateway.filter.NettyRoutingFilter.filter(NettyRoutingFilter.java:125) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat org.springframework.cloud.gateway.handler.FilteringWebHandler$GatewayFilterAdapter.filter(FilteringWebHandler.java:138) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat org.springframework.cloud.gateway.filter.OrderedGatewayFilter.filter(OrderedGatewayFilter.java:44) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat org.springframework.cloud.gateway.handler.FilteringWebHandler$DefaultGatewayFilterChain.lambda$filter$0(FilteringWebHandler.java:118) ~[spring-cloud-gateway-core-2.1.2.RELEASE.jar:2.1.2.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:44) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\tat reactor.core.publisher.MonoDefer.subscribe(MonoDefer.java:52) ~[reactor-core-3.3.3.RELEASE.jar:3.3.3.RELEASE]\n\n\n\n配置路由的过滤器AddRequestHeader这里我新建了一个application-dev.yml，原来的application.yml中加入配置\n123spring:  profiles:    active: dev\n\ndev配置如下:\n1234spring:  cloud:    gateway:      routes:\n\n我在测试是否存在覆盖的时候，发现配置上面这种情况。application.yml中的routes全部失效。这点的确没有想到。目前的结论是无法分文件配置，只能写在一个文件里面。\n123456789101112131415spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          predicates:            - Path=/get        - id: route          uri: http://httpbin.org          filters:            #添加请求头X-Request-re:blue            - AddRequestHeader=X-Request-red, blue          predicates:            - Path=/get\n\n上图我再次测试了是不是按顺序进行匹配的，测试结果是没有加请求头X-Request-red，所以就是上面说的，匹配到，就结束。\n还有一种就是predicates中设置的变量filters中可以使用如下：\n1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:          #添加请求头参数red:blue-&#123;segment&#125;，segment是取去请求Path里面的值            - AddRequestHeader=X-Request-red, blue-&#123;segment&#125;          predicates:            - Path=/anything/&#123;segment&#125;\n\n这种情况测试没有成功，这下我有经验了，我将spring-cloud-dependencies版本升级了了，spring-boot-starter-parent也升级了，配置如下：\n1234567&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;&lt;version&gt;Hoxton.RELEASE&lt;/version&gt;\n\n结果他成功了，真是不让人不省心啊。。。。然后我趁热打铁测了一下上面覆盖的问题，发现问题还是存在application.yml中的routes还是全部失效。\nAddRequestParameter1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            #添加请求参数red=blue-&#123;segment&#125;，segment是取去请求Path里面的值            - AddRequestParameter=red, blue-&#123;segment&#125;          predicates:            - Path=/anything/&#123;segment&#125;\n\nAddResponseHeader1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            #添加响应头red=blue-&#123;segment&#125;，segment是取去请求Path里面的值            - AddResponseHeader=X-Response-Red, Blue          predicates:            - Path=/anything/&#123;segment&#125;\n\nDedupeResponseHeader这个就是干掉重复的响应头，有人肯定就会迷惑，怎么会出现重复的响应头，刚好本人在开发中遇到过这个问题，就是在解决跨域问题，我程序里面加了一个Access-Control-Allow-Origin:*，然后运维在nginx上也加了一个，所以出现了两个一样的响应头。既然有两个，肯定是有保留哪一个的问题，这个提供3种RETAIN_FIRST（这个是默认项，保留第一个），RETAIN_LAST(保留最后一个)，RETAIN_UNIQUE(保留唯一的)\n1234567891011121314spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Response-Red, Blue1            - AddResponseHeader=X-Response-Red, Blue2            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue4          predicates:            - Path=/anything/&#123;segment&#125;\n\n我们先给他添一下响应头，响应头结果如下\n123456789101112HTTP/1.1 200 OKX-Response-Red: Blue1X-Response-Red: Blue2X-Response-Yellow: Blue3X-Response-Yellow: Blue3X-Response-Yellow: Blue4Date: Sun, 08 Mar 2020 16:12:42 GMTContent-Type: application/jsonContent-Length: 652Server: gunicorn/19.9.0Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true\n\n这个时候我们加入DedupeResponseHeader\n12345678910111213141516spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Response-Red, Blue1            - AddResponseHeader=X-Response-Red, Blue2            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue3            - AddResponseHeader=X-Response-Yellow, Blue4            - DedupeResponseHeader=X-Response-Red,RETAIN_LAST            - DedupeResponseHeader=X-Response-Yellow,RETAIN_UNIQUE          predicates:            - Path=/anything/&#123;segment&#125;\n\n运行结果如下\n12345678910HTTP/1.1 200 OKDate: Sun, 08 Mar 2020 16:19:52 GMTContent-Type: application/jsonContent-Length: 652Server: gunicorn/19.9.0Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: trueX-Response-Yellow: Blue3X-Response-Yellow: Blue4X-Response-Red: Blue2\n\n结果一目了然，X-Response-Red保留最后就是Blue2,X-Response-Yellow保留唯一的就是删掉了重复的Blue3，还有一种写法，如果都采用默认策略，可以直接这样写，两个响应头之间用空格隔开。\n1- DedupeResponseHeader=X-Response-Red X-Response-Yellow\n\nCircuitBreaker首先解释一下，这个玩意叫断路器。这里支持两种Hystrix和Resilience4J。官方文档推荐Resilience4J，说Hystrix现在被标记为只维护了。然后我去招聘网上在深圳收了一下Resilience4J，一家都没有…..然后又搜了一下Hystrix，就只有5家……实话说我也只对Hystrix眼熟，所以这里我们主要讨论一下Hystrix。由于篇幅原因，我在另一篇博文里面专门讲解。\nMapRequestHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddRequestHeader=X-Request-1, 1            - AddRequestHeader=X-Request-2, 2            - MapRequestHeader=X-Request-1,X-Request-2          predicates:            - Path=/anything/&#123;segment&#125;\n\n说白了就是复制一个和X-Request-1一样的值的请求头X-Request-2，如果XRequest-2之前就已经存在，就把原来的值包括进去。记住是复制一个，原来的头还在那里，看下图的结果就明白了\n12345678910111213141516171819202122&#123;  \"args\": &#123;&#125;,   \"data\": \"\",   \"files\": &#123;&#125;,   \"form\": &#123;&#125;,   \"headers\": &#123;    \"Accept\": \"*/*\",     \"Accept-Encoding\": \"gzip,deflate\",     \"Content-Length\": \"0\",     \"Forwarded\": \"proto=http;host=\\\"localhost:8080\\\";for=\\\"127.0.0.1:61222\\\"\",     \"Host\": \"httpbin.org\",     \"User-Agent\": \"Apache-HttpClient/4.5.8 (Java/11.0.3)\",     \"X-Amzn-Trace-Id\": \"Root=1-5e65bea6-8c228e8c8017cd5df1ff75a5\",     \"X-Forwarded-Host\": \"localhost:8080\",     \"X-Request-1\": \"1\",     \"X-Request-2\": \"2,1\"  &#125;,   \"json\": null,   \"method\": \"GET\",   \"origin\": \"127.0.0.1, 113.57.247.0\",   \"url\": \"http://localhost:8080/anything/haha\"&#125;\n\n然后我测试了一下filters是不是有顺序的，将MapRequestHeader移到最上面，结果是没有生效，所以filters是按顺序执行的。然后我测试了之前的DedupeResponseHeader放在上面，发现没有影响，我猜他每个部分有一个整体顺序，每个部分的内部是按配置顺序来，反正按照逻辑顺序写就对了。\nPrefixPath12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - PrefixPath=/anything          predicates:            - Path=/get\n\n把匹配到的路径加一个前缀/anything，http://localhost:8080/get的结果就变成了http://localhost:8080/anything/get\nPreserveHostHeader12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - PreserveHostHeader          predicates:            - Path=/get\n\n没加PreserveHostHeader\n123456789101112131415&#123;  \"args\": &#123;&#125;,   \"headers\": &#123;    \"Accept\": \"*/*\",     \"Accept-Encoding\": \"gzip,deflate\",     \"Content-Length\": \"0\",     \"Forwarded\": \"proto=http;host=\\\"localhost:8080\\\";for=\\\"127.0.0.1:62728\\\"\",     \"Host\": \"httpbin.org\",     \"User-Agent\": \"Apache-HttpClient/4.5.8 (Java/11.0.3)\",     \"X-Amzn-Trace-Id\": \"Root=1-5e65c53a-6e62e57803de635ad7a1795c\",     \"X-Forwarded-Host\": \"localhost:8080\"  &#125;,   \"origin\": \"127.0.0.1, 113.57.247.0\",   \"url\": \"http://localhost:8080/get\"&#125;\n\n加了PreserveHostHeader\n123456789101112131415&#123;  \"args\": &#123;&#125;,   \"headers\": &#123;    \"Accept\": \"*/*\",     \"Accept-Encoding\": \"gzip,deflate\",     \"Content-Length\": \"0\",     \"Forwarded\": \"proto=http;host=\\\"localhost:8080\\\";for=\\\"127.0.0.1:62634\\\"\",     \"Host\": \"localhost\",     \"User-Agent\": \"Apache-HttpClient/4.5.8 (Java/11.0.3)\",     \"X-Amzn-Trace-Id\": \"Root=1-5e65c4fe-aa95f72094a2cfa02e0408e0\",     \"X-Forwarded-Host\": \"localhost:8080\"  &#125;,   \"origin\": \"127.0.0.1, 113.57.247.0\",   \"url\": \"http://localhost:8080/get\"&#125;\n\n差别在Host请求头上，PreserveHostHeader没有参数，意思是保留Host头，加了就是用请求url上的host，不加就是路由配置uri里面host\nRequestRateLimiter限流这一块没有快捷配置，我们单独拿出来讲解。\nRedirectTo重定向，有两个参数一个status，一个url。status对应是300系列的重定向状态码。下图配置就是返回一个状态码为302，然后响应头里面有一个Location: https://baidu.com，说白了就是跳转到百度\n12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - RedirectTo=302,https://baidu.com          predicates:            - Path=/get\n\nRemoveRequestHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddRequestHeader=X-Request-1, 1            #如果存在则移除请求头X-Request-1            - RemoveRequestHeader=X-Request-1          predicates:            - Path=/get\n\nRemoveResponseHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Request-1, 1            #如果存在则移除响应头X-Request-1            - RemoveRequestHeader=X-Request-1          predicates:            - Path=/get\n\n如果有一个公共的响应头，里面的值过于敏感，不能显示给调用者，然后一个个的添加过滤很显然不符合实际，这个时候有一个全局过滤default-filters。\n123456789101112spring:  cloud:    gateway:      default-filters:        - RemoveResponseHeader=X-Response-Red      routes:        - id: route          uri: http://httpbin.org          filters:            - AddResponseHeader=X-Response-Red, Blue1          predicates:            - Path=/get\n\nRemoveRequestParameter1234567891011spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            #添加请求头移除请求参数name            - RemoveRequestParameter=name          predicates:            - Path=/get\n\nRewritePath12345678910spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          filters:            - RewritePath=/red(?&lt;segment&gt;/?.*), $\\&#123;segment&#125;          predicates:            - Path=/anything/**\n\n按照正则表达式重写路径，RewritePath有两个参数第一个是正则表达式，第二个是替换的参数。上面的配置就是访问http://localhost:8080/anything/red/blue，被替换成http://localhost:8080/anything/blue。\nRewriteLocationResponseHeader还没测试貌似有点绕，先贴个官方示例\n12345678spring:  cloud:    gateway:      routes:      - id: rewritelocationresponseheader_route        uri: http://example.org        filters:        - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, ,\n\nRewriteResponseHeader123456789101112spring:  cloud:    gateway:      routes:        - id: route          uri: http://httpbin.org          predicates:            - Path=/anything/**          filters:            - AddResponseHeader=X-Response-Red, password=123            #修改响应头里面的值，以下三个变量分别代表：响应头名字、正则表达示匹配内容、替换上的值            - RewriteResponseHeader=X-Response-Red, password=[^&amp;]+, password=***\n\nSaveSession12345678910spring:  cloud:    gateway:      routes:      - id: save_session        uri: https://example.org        predicates:        - Path=/foo/**        filters:        - SaveSession\n\nSecureHeaders添加一响应头，默认如下\nX-Xss-Protection:1 (mode=block)Strict-Transport-Security (max-age=631138519)X-Frame-Options (DENY)X-Content-Type-Options (nosniff)Referrer-Policy (no-referrer)Content-Security-Policy (default-src &#39;self&#39; https:; font-src &#39;self&#39; https: data:; img-src &#39;self&#39; https: data:; object-src &#39;none&#39;; script-src https:; style-src &#39;self&#39; https: &#39;unsafe-inline)&#39;X-Download-Options (noopen)X-Permitted-Cross-Domain-Policies (none)SetPath12345678910spring:  cloud:    gateway:      routes:      - id: setpath_route        uri: https://example.org        predicates:        - Path=/red/&#123;segment&#125;        filters:        - SetPath=/&#123;segment&#125;\n\nSetRequestHeader12345678spring:  cloud:    gateway:      routes:      - id: setrequestheader_route        uri: https://example.org        filters:        - SetRequestHeader=X-Request-Red, Blue\n\n12345678910spring:  cloud:    gateway:      routes:      - id: setrequestheader_route        uri: https://example.org        predicates:        - Host: &#123;segment&#125;.myhost.org        filters:        - SetRequestHeader=foo, bar-&#123;segment&#125;\n\nSetResponseHeader12345678spring:  cloud:    gateway:      routes:      - id: setresponseheader_route        uri: https://example.org        filters:        - SetResponseHeader=X-Response-Red, Blue\n\n12345678910spring:  cloud:    gateway:      routes:      - id: setresponseheader_route        uri: https://example.org        predicates:        - Host: &#123;segment&#125;.myhost.org        filters:        - SetResponseHeader=foo, bar-&#123;segment&#125;\n\nSetStatus123456789101112spring:  cloud:    gateway:      routes:      - id: setstatusstring_route        uri: https://example.org        filters:        - SetStatus=BAD_REQUEST      - id: setstatusint_route        uri: https://example.org        filters:        - SetStatus=401\n\n123456spring:  cloud:    gateway:      set-status:      #可以将原来的响应码放在这个头里，如果正常响应则original-http-status: [200]        original-status-header-name: original-http-status\n\nStripPrefix12345678910spring:  cloud:    gateway:      routes:      - id: nameRoot        uri: https://nameservice        predicates:        - Path=/name/**        filters:        - StripPrefix=2\n\n通过网关/name/blue/red发出请求时，请求路径变成/red\nRetry123456789101112131415161718192021222324252627spring:  cloud:    gateway:      routes:        - id: route          uri: http://localhost:8081          predicates:            - Path=/test/get          filters:            - name: Retry              args:                #重试三次，加上第一次一共四次                retries: 3                #响应码为502进行重试                status: 502                #请求方法是GET，或者Post才重试                methods: GET,POST                #一系列响应码就是5开头就是服异常，不能写数值，与status同时配置，status失效 #INFORMATIONAL(1),SUCCESSFUL(2),REDIRECTION(3),CLIENT_ERROR(4),SERVER_ERROR(5);                series: CLIENT_ERROR                #应该重试的异常列表，我这样配置没有生效                exceptions: java.io.IOException                #下面几个参数没搞明白                backoff:                  firstBackoff: 10ms                  maxBackoff: 50ms                  factor: 2                  basedOnPreviousValue: false\n\n如果直接开启默认配置如下，一般开启默认就行了- Retry\nretries: Three timesseries: 5XX seriesmethods: GET methodexceptions: IOException and TimeoutExceptionbackoff: disabledRequestSize现在上传数据大小,默认是5MB，超过了会提示HTTP/1.1 413 Request Entity Too LargeerrorMessage: Request size is larger than permissible limit. Request size is 1.4 MB where permissible limit is 1.0 kBModifyRequestBody这个只能用JAVA DSL配置，如下示例ModifyResponseBody这个只能用JAVA DSL配置，如下示例default-filters默认过滤对全局生效，之前的应都支持总结这次给我最大的感悟就是，在引入包的时候，版本一定要统一！一定要统一！一定要统一！重要的事情说3遍，2.2.x就对应2.2.x，千万被跨大版本，要不然各种坑！\n参考https://spring.io/guides/gs/gateway/\nhttps://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-starter\n","plink":"https://blog.bugbak.com/2020/03/06/SpringCloudGateway/"},{"title":"CAP理论","date":"2020-03-01T20:01:11.000Z","date_formatted":{"ll":"Mar 1, 2020","L":"03/01/2020","MM-DD":"03-01"},"updated":"2020-03-11T02:22:08.745Z","content":"什么是CAP理论在理论计算机科学中，CAP理论指出，分布式数据存储（这里要注意是分布式储存）不可能同时提供以下三个保证中的两个以上：\n分区容错性（Partition tolerance）我觉得先讲P对于理解下面的CA会好一点。因为我觉得没有P就没有下面CA的问题。首先我们先拆开理解什么叫分区，什么叫容错性。\n分区：就是在一个分布式系统里面，节点组成的网络本来应该是连通的，然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。容错性：当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了，这时分区就没有容错性。提高分区容错性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里，就有了容错性。所以结合起来分区容错性，就是有联系的多个节点之间断开了，且都保存同一份数据 ，而且两个分区的节点都还要是正常运行的。\n一致性（Consistency）首先注意该一致性与ACID 数据库事务中保证的一致性完全不同。上面我对P的讲解的，就好理解了一致性就是所有节点在同一时间的数据完全一致。比如两个节点node1，node2，他们都有同一个变量a=0，当我修改node1数据a=1后，访问node2也返回的a=1。一致性又分为两类：\n强一致性：复制数据是同步的。弱一致性：复制数据是异步的。这里一致性指的是强一致性。\n可用性（Availability）首先强调一下我们日常谈论到的“高可用性“是指停机时间，比如99.999%就是说我全年只停机365x24x60x(1-0.99999)=5.256分钟，这个”高可用性“和这里的可用性完全不是同一个概念。CAP中的A指的是系统中无故障的[数据库]节点收到的每个请求都必须产生[无错误]响应”。\n如何理解CAP定理只能满足两项分布式存储中，是不可能保证网络不出问题的，所以P是肯定满足的。如下图，G1和G2是两个节点，两个都维护这一个数据v0。\n\n这个时候client修改v0为v1。\n保证一致性，这个时候G1就应该把V1同步给G2，可是他们之间网络出问题了，传不过去，这个时候怎么办？报错，不给处理，违背了可用性。保证可用性，这个是时候G1只把自己的数据修改为V1了，没管G2，返回正常。这个时候client再去访问G2返回的是v0，很明显数据不一致了，违背了一致性。所以由上面的例子分布式CAP只能满足两项，要么CP，要么AP。\n参考https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/    \nhttps://www.zhihu.com/question/54105974\nhttps://dzone.com/articles/understanding-the-cap-theorem\n","plink":"https://blog.bugbak.com/2020/03/01/CAP理论/"},{"title":".gitignore语法规范","date":"2020-02-28T10:47:12.000Z","date_formatted":{"ll":"Feb 28, 2020","L":"02/28/2020","MM-DD":"02-28"},"updated":"2020-03-11T02:22:39.785Z","content":".gitignore为何物？从名字就可以看出来，就是在git里面忽略一些文件，比如：idea打开项目后的.idea文件。这些文件没有必要上传到git仓库，而且每个人idea的配置可能还不一样，pull下来别人的配置还可能会导致一些谜之问题。这时候聪明的同学肯定就会说，把不需要的文件不add到git中不就可以了吗？没错，让git不去管理这些文件的确是可以的，但人都会犯错，不保证每个人都不会将这些文件提交上去，但是被gitignore忽视的这些文件，是永远都提交不上去的，就可以化解人为的操作失误。\n如何使用.gitignore在项目的根目录里面也就是.git文件夹的同级目录下创建一个.gitignore文件，看不见.git文件夹的，打开显示隐藏文件夹。注意.gitignore这个名字已经包括了名称和后缀，千万别创建了一个.gitignore.txt文件。创建好之后我们按照官方给定的语法进行配置，就可以指定忽略哪些文件或文件夹。\n.ignore语法示例文字都是苍白的，下面我们来实操一波，以下都是我实测所得，如有纰漏，欢迎评论指出！\n注：配图中黄色是被git忽略的\n12345678# *用来匹配零个或多个字符，忽略所有.txt后缀的文件*.txt# 如果想让a.txt不被忽略，可以加上！注意：顺序和上面颠倒会失效!a.txt# 忽略所有a.txt,b.txt文件，不包括ab.txt，[]用来匹配括号内任意一个字符，[0-9]匹配0到9的数[ab].txt# 用?配单个字符，忽略a.txt,不会略ab.txt?.txt\n\n123#忽略所有doc文件夹里面所有，不管doc是否为一级二级，这里的一级指的是和.gitignore同级，这两个效果一致docdoc/\n\n\n12# 忽略doc文件夹下所有，不包括/dom/doc，也就是它作为一级目录下递归所有/doc\n\n\n12# 忽略doc作为一级目录下的，不包括/dom/doc/a.txt,不包括子目录/doc/img/a.txtdoc/*.txt\n\n\n12# 忽略doc作为一级目录下的，二级目录里面的txt文件，不包括第三级目录，额。。。懵逼了，还是看图吧，一图胜千言doc/*/*.txt\n\n\n12# 忽略doc作为一级目录下的所有.txt文件doc/**/*.txt\n\n\n补充说明使用idea开发项目的小伙伴可以下载插件.ignore，被忽略的文件或者文件夹会改变颜色。这样就可以很轻松的辨别自己的配置是否成功。\n参考https://git-scm.com/docs/gitignore\n","plink":"https://blog.bugbak.com/2020/02/28/gitignore语法规范/"},{"title":"About Me","date":"2019-07-20T09:43:19.000Z","date_formatted":{"ll":"Jul 20, 2019","L":"07/20/2019","MM-DD":"07-20"},"updated":"2020-03-05T11:23:20.968Z","content":"首先告诉你一个不幸的消息，你将会在这个页面失去1分钟的青春。但是！莫慌~通过阅读鄙人的blog你可以节省至少X小时的青春嗯 ？ X？？你细品~有人可能会问鄙人为什么决定写blog？问的好！鄙人在互联网搬砖也有些年头了最明显的不是肌肉变发达了而是头发少了咳咳~是记忆力消退没错东西写出来肯定就不会丢了啊这时候肯定就有狼人跳出来指着我的鼻子说数据库炸了不久丢了吗？说的好，所以我。。。一拳打爆你的狗头哦~开个玩笑~最后如果我的输出能让大家有所收获那可真是令人开心哦~哈哈哈哈哈~\n","plink":"https://blog.bugbak.com/about/me/"}]